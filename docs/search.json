[
  {
    "objectID": "lesson07.html",
    "href": "lesson07.html",
    "title": "Introduction to Data Structures",
    "section": "",
    "text": "The algorithms we design to solve problems rarely do so without requiring some sort of input and producing some sort of output. In the process, our algorithms do something with the inputs (e.g., number crunching, processing, and so on). That is, algorithms typically manipulate the inputs in some way. Think about what that means. Where is the information? What does it look like? How is it accessed? How is it manipulated? Where does it go? We generally refer to the inputs being processed and the output(s) being generated as data.\n\n\n\n\n\n\nDefinition\n\n\n\nData is a term given to pieces of information that can berepresented, stored, or manipulated using a computer. Often, combining data provides meaning (i.e., information).\n\n\nAlthough data is useful and necessary, it is not yet meaningful. The idea is that our algorithms will process this data and produce some sort of output (or result). In the process, meaning is given to the data. We call this information."
  },
  {
    "objectID": "lesson07.html#creating-the-list",
    "href": "lesson07.html#creating-the-list",
    "title": "Introduction to Data Structures",
    "section": "Creating the list",
    "text": "Creating the list\nCreate an empty list named numbers using a simple assignment statement:\n    numbers = []\nCurrently, the list is empty (i.e., its length is 0). In fact, this can be confirmed using one of the list methods shown above:\n    print(len(numbers))"
  },
  {
    "objectID": "lesson07.html#populating-the-list-with-random-integers",
    "href": "lesson07.html#populating-the-list-with-random-integers",
    "title": "Introduction to Data Structures",
    "section": "Populating the list with random integers",
    "text": "Populating the list with random integers\nLet’s populate the list with 20 random integers. While it is possible (albeit tedious) to populate the list by adding each value individually, instead we are going to create a short program to make the population process automated.\nBecause the population process calls for a specific task (i.e., the addition of an item to the list) to be repeated over and over again, let’s use the while loop with a counter (initialized to 0). Let’s now declare the counter. Note that statements already shown above are included, and new statements are highlighted:\n    numbers = []\n    counter = 0\nBecause our task is going to be done 20 times (in order to fill the list with 20 values), we can structure the while loop as follows:\n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        # add a random number to the list\n        counter += 1\nNote that the comment (beginning with #) will be replaced later. It is just informative at this point. Notice how the counter is incremented at the end of the while loop. This is necessary because it allows it to progress from 0 to 20, guaranteeing that the condition in the while loop will eventually be false (i.e., counter will be greater than or equal to 20). This stops the repetition, allowing control to continue past the while loop.\nNow, what number will we be actually adding to the list? Well, we want to add 20 randomly selected numbers to the list. To generate random numbers, we can make use of a Python library called random; specifically, a function in the library called randint. Libraries and how to import them in Python programs will be discussed in more detail in a later lesson. For now, we’ll simply show how to import the randint function from the random library:\n    from random import randint\n\n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        # add a random number to the list\n        counter += 1\nNext, let’s generate a random integer from 1 to 99:\n    from random import randint\n\n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        num = randint(1, 99)\n        counter += 1\nNote that the randint function takes two parameters: a lower bound and an upper bound. The function returns a random integer from the lower bound to the upper bound, inclusive. So far, we’ve just generated 20 random numbers from 1 to 99. We’re not actually adding them to the list! Let’s do this now using the append list function shown above:\n    from random import randint\n    \n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        num = randint(1, 99)\n        numbers.append(num)\n        counter += 1\nYou have now created a list (which we called numbers) and filled it with 20 random integers. If any of the following activities require a list filled with random numbers, you can easily refer to the above steps and create one. If you require a larger or smaller array, its just a matter of changing the value in the while loop. If you require values in a different range (perhaps numbers between 100 and 1000), its just a matter of changing the values in the randint function.\nThe generated list can be displayed as follows:\n    from random import randint\n\n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        num = randint(1, 99)\n        numbers.append(num)\n        counter += 1\n\n    print(numbers)\nThe output generated will look something like this (of course, your list will look different):\n[82, 17, 85, 8, 2, 7, 33, 13, 24, 89, 49, 37, 61, 72, 83, 39, 23, 58, 45, 31]\nYou may wonder why we store a randomly generated integer in the variable num in the program above. It’s not used for anything other than being added to the list. In fact, the variable num is actually not necessary. The algorithm above can be modified without changing its behavior as follows:\n    from random import randint\n    \n    numbers = []\n    counter = 0\n    while (counter &lt; 20):\n        numbers.append(randint(1, 99))\n        counter += 1\n    print(numbers)\n\nThe randomly generated integer is generated and immediately added to the list!\nAs a last observation, it is often good practice to use constants to specify target or desired values. For example, using a constant to specify the list’s desired size can be useful. Any point in the program that needs the list’s target size can refer to the constant. If it needs to be changed at a later time, the constant value simply needs to be changed, and all references to it through the constant won’t have to also be updated. Here’s a modification of the above program that implements this:\n    from random import randint\n    \n    SIZE = 20\n    numbers = []\n    counter = 0\n    while (counter &lt; SIZE):\n        numbers.append(randint(1, 99))\n        counter += 1\n    print(numbers)\n\n\nFinally, recall that one of the list methods shown above returns the list’s size. We can use it instead of a counter to repeatedly insert integers into the list until it has reached the desired size:\n    from random import randint\n    \n    SIZE = 20\n    numbers = []\n    while (len(numbers) &lt; SIZE):\n        numbers.append(randint(1, 99))\n    print(numbers)\n\nNote that all statements referring to the variable counter have been removed. As integers are inserted into the list, its length increases. Therefore, len(numbers), initially 0, increases by one each time an integer is inserted into the list. Eventually, len(numbers) will be 20, and control will continue past the while loop."
  },
  {
    "objectID": "lesson05.html",
    "href": "lesson05.html",
    "title": "Introduction to Computer Architecture",
    "section": "",
    "text": "Computer architecture is a wide branch of computer science that seeks to find answers to questions such as, “What makes up a computer?” and, “How is it that we can use a computer?” The answers to these questions are continuously changing, but we will attempt to give a simple answer in this lesson.\nIn a previous lesson, we discussed how computer hardware works. Recall that all general-purpose computers, at a minimum, consist of the following hardware components: a central processing unit(CPU), main memory, secondary storage, various input/output (I/O) devices, and a data bus. The data bus is like a highway that the other components use to communicate with each other. Main memory is used to store data and programs that are currently being used. I/O devices allow the outside world to communicate with the computer. The CPU is the device that is responsible for actually executing the instructions that make up a program.\nLet’s further discuss the brains of the computer, the CPU. The operation of the CPU is governed by the instruction cycle.\n\n\n\n\n\n\nDefinition\n\n\n\nThe instruction cycle is a procedure that consists of three phases: instruction fetch, instruction decode, and instruction execution\n\n\nThe CPU’s task is to perform the instruction cycle over and over until explicitly instructed to halt. The fetch phase of the instruction cycle consists of retrieving an instruction from memory. The decode phase concerns determining what actions the instruction is requesting the CPU to perform. Instruction execution involves performing the operation requested by the instruction.\n\nThe layers of a computer system\nTo fully understand computer architecture, it is important to understand the idea of abstraction as it is used in the field of computer science. Abstraction is an idea of dealing with complex and interconnected systems whereby a user is only interested in the operations of a certain level of complexity and suppresses more complex details. Abstraction is analogous to looking at Google map of a large country,such as the USA. We can see the individual states, large lakes, surrounding oceans, and neighboring countries. At this level of abstraction, one is unable to see the finer details within a state (such as the names of cities, towns, and major roads). However, zooming in provides an increased level of detail. The entire country is no longer visible; instead, perhaps only a single state (e.g., Louisiana) and its neighbors are visible. At this zoomed in level, we can now see some of the cities and major roads. However, we cannot see some of the details of the zoomed out level such as the states that are not immediate neighbors or the oceans. If we zoom in to an even lower level, we can see street names,major buildings, and so on. Again, we lose some of the details at the higher levels. Dividing a complex system (like a map) into levels that progressively abstract away detail allows users of the system to only deal with information that is relevant at a given time.\n\n\n\nFigure 1: The multiple layers of a computer\n\n\nA computer is a very complex system consisting of multiple layers (see Figure 1). At the very top is the user. Users interact with computers in a variety of ways. That is, they can (and do) interact directly with applications (like a spreadsheet application, a game, or a Web browser). Users can also interact directly with the operating system (e.g., through its GUI or via the console) and with system utilities (think of applications that are provided by the operating system). The** application layer** is the next layer immediately below the user. It is the layer that a computer user typically interacts with. For example, a user can type and send an email without needing to know how the characters on the screen are made to appear on another computer perhaps one thousand miles away. A user might double-click an audio file on the desktop without needing to know how the computer understands what a double-click is or how to “play” the audio file.\nThe next layer is the operating system layer. This layer understands user inputs (like typing or double-clicks) and figures out ways of interpreting and executing those inputs. There are many examples of operating systems (e.g., Linux, Windows, MacOS, Unix, Solaris). Of these, Window is still the most common. What is the operating system on your Raspberry Pi? At its core, the operating system is what allows users to interact with the computer and actually make use of it.\nSystem utilities are like applications, but provided directly by the operating system. In one sense, they provide an interface to certain parts of the operating system that allow users to do frequently needed things. For example, the system utility of copying or moving files is often used. Users don’t have to install an application that permits copying and moving files around. This is a system utility provided by the operating system. Since system utilities are essentially embedded in the operating system, this layer sits at the same level as the operating system layer.\nThe layer beneath the operating system layer is the hardware abstraction layer (or HAL). Sometimes, this layer is referred to as the device driver layer. There are many different types and designs of computers, and this layer makes sure that the computer hardware acts the same regardless of the computer’s design. For example, it makes sure that the “on” button switches on the computer regardless of where it is located. It makes sure that hitting a specific button opens the CD drive. It provides the operating system with clear instructions on how it can interact with the physical hardware of the computer.\nThe bottom layer is the hardware layer. It represents the physical, tangible stuff that you can see or touch (e.g., keyboard, monitor, mouse, case, power supply, motherboard, etc).\n\n\nFundamentals of digital logic\nBecoming really good at computer science means having a good understanding of all of the layers, what they do, and how they are used. We will spend most of this lesson dealing with the hardware layer.\nA lot of devices have two states: a voltage is high or low, a switch is open or closed, a light is on or off. There are many ways of modeling these two-state systems; some are very concrete and some are more abstract. We’ll look at a number of these models, beginning with simple models that are based on mechanical switches and light bulbs.\nOne of the most basic electrical connection is a light bulb that is either connected to a power source (or not). A slightly more complicated version of this includes a switch that can be either open or closed.These switches are similar to the electrical switches in your home. We will assume that these switches are connected to a source of power that can supply current. The potential of a power source, such as a battery, is called voltage and is measured in units called volts (V). Voltage sources typically have a positive and negative end (called a terminal), and the difference in the potential between both terminals is what we use as the measurement of voltage. Voltage sources can produce either alternating current (AC) or direct current (DC). With DC, one terminal is always positive, and the other is always negative. Examples of DC sources are batteries such as the ones you would put in a small radio, watch, or flashlight. With AC, the two terminals keep on swapping positive and negative roles very quickly (60 times per second!). Examples of AC sources are wall outlets that you would typically find in your home.\nThe simplest circuit that can be built contains a power supply, a single switch, and a light bulb. If the switch is open, the light is off; if the switch is closed, the light is on. The following figure illustrates both of these cases:\n\n\n\n\n\nThe state of these two circuits can be expressed in table form as follows:\n\n\n\n\n\nWe can increase the complexity of this circuit somewhat by adding a second switch between the first switch and the light bulb. This results in four possible configurations: (1) both switches are open; (2) the first switch is open and the second is closed; (3) the first switch is closed and the second is open; and (4) both switches are closed. This is illustrated in the figure below. These circuits are called series circuits since the two switches occur on the same path from the power source back to itself. In series circuits, when either one or both of the switches are open power will not flow, and the light bulb will be off. Only when both switches are closed does power flow, and the light bulb illuminates. Said another way: if both switch A and switch B are closed, then the light will turn on.\n\n\n\n\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb(on or off) is summarized in the following table:\n\n\n\n\n\nAnother type of circuit can be designed using two switches. This second type of circuit arranges the switches in parallel rather than in series. In a two-switch parallel circuit, each of the switches is placed on a separate path between the power source and the light bulb. The figure below illustrates the four possible configurations of a two-switch parallel circuit. As was the case with the series circuits, there are four possible configurations of the circuit (in fact, they are exactly the same as before). When both switches are open power does not flow and the light bulb is off. However, whenever either or both of the switches are closed, power flows and the light will turn on. Said another way, if switch A or switch B is closed, then the light will turn on.\n\n\n\n\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb (on or off) is summarized in the following table:\n\n\n\n\n\nMore complex circuits with three or more switches are possible!\n\n\n\n\n\n\nActivity 1: LED the Way (preview)\n\n\n\n\n\nThe next Raspberry Pi activity will involve implementing various circuits that illustrate some of the ones covered above. Initially, the Raspberry Pi will only be used as a power source. We will be connecting it to a circuit prototyping board called a breadboard, and the Raspberry Pi will provide power to the breadboard. A breadboard is used to simplify the process of prototyping connections between electronic components. It allows the making of secure connections between simple electronic devices by simply plugging them into appropriate rows or columns of the board. Here’s an example of a breadboard:\n\n\n\n\n\nThe holes in the breadboard allow electronic components (including wires) to be connected to each other. Note that there are internal connections within the breadboard. Each row along the top and bottom of the breadboard is connected. In addition, each column in the center portion is connected; however, there is a disconnect across the center gap:\n\n\n\n\n\nThe first part of the activity\nThe first part of the Raspberry Pi activity will simply be to connect a power supply to a light. Since the Raspberry Pi provides DC, the light we will use is called an LED. We’ll explain this later; but for now, here’s an example of the connected electronic components for this part of the activity:\nCircuit representation\n\n\n\n\n\nThe image above is an example of the topological layout of a circuit. That is, it does a pretty good job of showing how the circuit looks physically when connected. Of course, there are many more ways to layout this exact circuit, and this is just one way. This method of diagramming a circuit is called a layout diagram because it shows the physical layout of the electronic (and other) components.\n\n\n\n\n\n\nDefinition\n\n\n\nA circuit diagram (also known as a schematic) is another way of representing a circuit that only shows the connections and substitutes actual electronic components with standard symbols.\n\n\n\n\n\n\n\nHere’s an example of the above circuit as a circuit diagram:\nA circuit diagram is a useful way to represent a circuit. Note how it can topologically be laid out in a number of ways. Various electronic components have unique symbols. For example (in the circuit diagram above), the LED has the following symbol:\n\n\n\n\n\nThe resistor has the following symbol:\n\n\n\n\n\nThe large rectangular object with lines coming out of it is the Raspberry Pi. Technically, this represents the GPIO pins on the Raspberry Pi. We’ll discuss this more later. We will also show more electronic components and their symbols later.\nThe components\nLet’s go through the components, one-by-one. At the bottom is the Raspberry Pi. You will notice that there are two wires connecting some pins on the RPi to the breadboard. We typically use red wires to signify positive voltage and black wires to signify negative voltage. In DC, the negative side is called ground. So red wires connect positive power to something, and black wires connect something to ground.\nThe red “light” in the circuit is called an LED (Light Emitting Diode). An LED is more convenient than a traditional light bulb, because it does not require high voltage in order to turn it on. In fact, it consumes such a small voltage that typical higher voltage levels would render the LED unusable. Be careful when using LEDs, and never connect them directly to a voltage source.\nAn LED allows current to flow through it in only one direction (from positive to negative). LEDs have a short leg and a long leg. The short leg is called the cathode and is the negative side. The long leg is called the anode and is the positive side. The head of an LED is also flat on one side: the negative (or cathode) side. LEDs come in various colors (the one in the circuit above is red, for example). The longer leg of an LED should always be connected to the positive side of your voltage source. If it isconnected backwards (i.e., with the shorter leg connected to the positive side), the LED will not light and may even burn out. For this reason, an LED should always be connected to a DC voltage source.\n\n\n\n\n\nSince most power sources are too strong for typical LEDs, we must reduce the current somewhat so that the LED does not become damaged. Resistors are typically used to resist the flow of electricity. When using them with LEDs, we typically connect a resistor in series with the LED. It doesn’t matter if the resistor is on the positive or negative side of the LED. It works the same in either case. Resistors come in various resistances. Resistance is measured in a unit called the ohm (Ω). Here is an example of a 220Ω resistor:\n\n\n\n\n\nWe can calculate the resistance required to resist the flow of electricity through the LED using Ohm’s Law. Ohm’s Law establishes a relationship between voltage, current, and resistance. Let’s first fully define each of these:\n\nVoltage is the difference in electric potential energy between two points. It can be considered as electric pressure and/or the work required to move electric charge between two points. The unit used to represent voltage is the volt (V).\nCurrent is the flow of electric charge (or electrons moving through a wire). The unit used to represent current is the ampere (A), or amps. We typically used the symbol I to represent current in a mathematical formula (such as Ohm’s Law).\nResistance is the measure of difficulty to pass an electric current through a conductor. A conductor is some material that allows the flow of electric current. The unit used to represent resistance is the ohm (Ω). We typically used the symbol R to represent resistance in a mathematical formula (such as Ohm’s Law).\n\nOhm’s Law is defined as the following:\n                                          V=IR\nStated formally, the voltage (electric potential difference) across two points on a circuit is equivalent to the product of the current between those two points and the total resistance of all electrical devices present between those two points.\nConsider the LED circuit above, where the red LED requires a forward voltage of 2V (i.e., the amount of voltage required across the LED to light it) and has a forward current of 20mA (i.e., the amount of current flow required through the LED to sufficiently power it on). These values are provided in the data sheet of the LED. A data sheet is a document that provides technical information about an electrical component.\nWe can calculate the resistance required in the circuit to ensure that the LED lights up properly and is not possibly damaged by having too much current move through it or too much voltage across it. Suppose that our power source (the Raspberry Pi) provides 3.3V. The voltage difference across the source voltage and ground is 3.3V (since ground is at 0V). According to the data sheet, the LED requires 2V across its legs and requires 20mA of current through it. Using Ohm’s Law we can solve for R. The value for V is 1.3V (3.3V at the source – 2V through the LED), and the value for I is 0.02A (20mA required through the LED). And now we solve: \\[ V = I * R \\] \\[(3.3V−2V ) = 0.02 A * R \\] \\[ 1.3V = 0.02 A * R \\] \\[65 = R\\]\nSo the resistance should be 65Ω. The closest valued resistor available is 68Ω. We can therefore use a 68Ω resistor in series with the LED. This should be sufficient to turn it on brightly without damaging it.\nYou may have noticed that resistors also have a wattage rating. To explain this, we must first discuss electric power. Electric power is the rate at which electric energy is transferred by a circuit. The unit used to represent power is the watt (W). Each component in a circuit dissipates power (as heat – usually through friction – as electrons move through the component). Therefore, each component has a power rating that provides a measure of how much power it can dissipate without breaking down. We can calculate the power dissipated in a circuit using a variant of Ohm’s Law:\n                                          P=VI\nThe power in a circuit is defined as the product of the voltage across two points on a circuit and the current between those two points. In the LED example above, the total power dissipated in the circuit is calculated as follows: \\[P = V * I\\] \\[P = 3.3V * 0.02 A\\] \\[P = 0.066W\\]\nTo calculate the power dissipated by each component, we simply need to isolate the voltage drop across each. The current is constant in the entire circuit. So for the LED, we can calculate the power dissipated as follows:\n\\[P = V * I\\] \\[P = 2V * 0.02 A\\] \\[P = 0.04W\\]\nSo we would need an LED rated at 0.04W. And for the resistor:\n\\[P = V * I\\] \\[P = (3.3V −2V ) * 0.02 A\\] \\[P = 1.3V * 0.02 A\\] \\[P = 0.026W\\]\nSo we would need a resistor rated at 0.026W.\nIn the end, we usually opt for a power rating that is greater than the actual power dissipated by the component (so that it can last a long time). A good target is not to exceed 60% of the wattage rating of the component. For the resistor, this means a power rating of 0.043W (0.026W / 0.6). Most typical resistors are rated at 0.25W (some are 0.125W and others are much higher). For the LED, this means a power rating of 0.067W (0.04W / 0.6), or 67mW. Most typical LEDs are rated at approximately 120mW. For this circuit, a typical LED rated at 120mW and a resistor rated at 1/8W would work just fine.\n\n\n\n\n\n\n\n\n\nDid you know?\n\n\n\nResistors have different values, and the value of a resistor can be determined by looking at the colored bands that surround its body. Because resistors are typically small in size (any letters written on one would be too small to be easily read), engineers invented a color code that can be used to calculate the resistance of a resistor. There are multiple online resources that can teach you how to read the value of a resistor from its colors.\n\n\n\n\n\n\n\n\nDid you know?\n\n\n\nBreadboards actually derive their name from a breadboard (i.e., a wooden board on which bread is often cut). This is because early versions of breadboards were made from the wooden bread cutting workstations.\n\n\n\n\nLogic gates\nGates are electronic versions of the mechanical switches introduced earlier. Some gates have multiple inputs, but all gates have a single output. Just as the switches and light bulbs of the previous examples were always in either of two states, the inputs and outputs of gates are confined to two voltage states. The voltage of every input to the gate, as well as the output from the gate, must be either high (positive voltage) or low (0V, or ground). We use the symbol “1” to represent the high voltage state and “0” to represent the low voltage state.\nThere are three basic kinds of logic gates: and gates, or gates, and not gates. An and gate has two inputs and one output. The output is “1” (high) only when both inputs are “1” (high). In all other cases the output of and is “0” (low). Here is the symbol for an and gate (where the two inputs are on the left, and the output is on the right):\n\n\n\n\n\nWe can represent the possible states of a gate in a truth table.\n\n\n\n\n\n\nDefinition\n\n\n\nA truth table defines the meaning of a gate, or circuit, by listing every possible configuration of inputs along with the corresponding output.\n\n\nTraditionally, inputs are listed on the left side of the table with the output on the right. Each row of the truth table represents one configuration that the circuit can be in. Truth tables for circuits with n inputs will always have exactly 2n rows, one for each possible configuration of the inputs. The following is the truth table for the and gate, where the inputs have been labeled A and B, and the output has been labeled Z:\n\n\n\n\n\nSince the and gate has two inputs, its truth table will contain \\(2^2= 4\\) rows. The first row of the truth table represents the situation in which both inputs to the and gate are low. In this case the output will be low as well. The second and third rows cover the cases in which one of the inputs is high and the other is low. In line two, the first input is low and the second is high; whereas in line three, the first input is high and the second is low. In either case, the output is low. The final row of the table represents the situation in which both inputs are high. In this case, the output will be high as well. The functionality of the and gate can be implemented by the series circuit introduced earlier:\n\n\n\n\n\nIf the switches represent the inputs, A and B, then this circuit correctly produces the output, Z, of an and gate (which is the light bulb in the circuit). In fact, compare the truth table for the and gate above with the truth table for the circuit:\n\n\n\n\n\nIf Open is replaced with 0 and Closed with 1, the tables are the same. The reason that truth tables are called as such is that if 1 is taken to mean true and 0 is taken to mean false, then the output of the table defines the circumstances under which the specified logical operation is true. For example, in common English usage, A and B will be true only when both A and B are true. The statement: “My cat is old and fat” is only true when the cat in question is both “old” and “fat.” If my pet cat were either young, or skinny, or both, then the statement would be false. The thing that is so exceedingly cool about logic gates, and the circuits that implement them, is that very simple devices can capture small parts of what humans consider logical reasoning. As you can well imagine, this idea caused great excitement when first discovered.\nThe or gate is similar to an and gate, in that it has two inputs and one output. The output of the or gate is 1 whenever either (or both) of the inputs are 1. The only case in which the output is 0 is when both of the inputs are 0. Here is the symbol and truth table for the or gate:\n\n\n\n\n\nAgain, the two inputs of the or gate are labeled A and B, and its output is labeled Z. Notice that the or gate can be implemented by the parallel circuit introduced earlier:\n\n\n\n\n\n\n\n\n\n\nYou should convince yourself that the behavior of the or gate captures the semantics of the word “or” as it is commonly used. The statement: “My cat is either on the couch or under the bed” is true if either the phrase “My cat is on the couch” is true or the phrase “my cat is under the bed” is true. The original statement is false only when neither of these phrases is true.\nThe third basic logic gate is the not gate. The not gate has a single input and a single output. The output is the inverse of the input. Here is the symbol and truth table for the not gate:\n\n\n\n\n\nNote that this truth table consists of only two rows rather than four (as was the case with the and and or gates). This is consistent with the claim that truth tables contain exactly \\(2^n\\) rows for an n input circuit. Since the not gate takes in only a single input, there are only two possible configurations that the gate can be in.\nAs with the and and or gates, the behavior of the not gate captures the semantics of the word. If the sentence: “My cat is black” is true, then the sentence “My cat is not black” would be false (and vice versa).\n\n\nCombining gates\n\n\n\n\n\nHere’s its truth table:\n\n\n\n\n\nSo long as either A or B is closed and C is closed, then the light bulb is lit. C must be closed in order for the bulb to be lit.\nIt is natural to ask at this point what an equivalent circuit consisting of logic gates would look like. Since switches A and B are in parallel, this portion of the circuit can be represented using an or gate. The output of that part of the circuit is in series with C, so it can be modeled with an and gate. The logic gate circuit shown below is thus equivalent to the switch circuit given above.\n\n\n\n\n\nIn fact, here is the truth table for this circuit:\n\n\n\n\n\nFor readability and to make it a bit easier to derive, we can expand the truth table to provide intermediate gate outputs as follows (where Z is the output of A or B, and Z’ is the output of Z and C):\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nCan you fill in the truth table for the circuit below? Let Z represent the output of A and B, and Z’ represent the output of Z or C.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoolean algebra\nThe arithmetic that is used to reason about two-state systems was first developed by George Boole in 1854.\n\n\n\n\n\n\nDefinition\n\n\n\nBoolean algebra is a mathematics based on three fundamental operators: and, or, and not; and the variables on which they operate.\n\n\nBoolean variables are binary, having only two valid states: 1 (representing true) and 0 (representing false).\nThe operator and is written as a dot “ ⋅ ”, or is written as a plus “+”, and not is written as a horizontal bar drawn over the expression being negated. The behavior of these three Boolean operators is identical to the behavior of the corresponding logic gates. Thus, the expression A⋅B , meaning A and B, will be 1 (true) when the variables A and B are both 1 (true). The expression A+B , meaning A or B, will be 1 when either or both variables are 1. The expression not A (written A ), will be 0 when A is 1 and 1 when A is 0. The relationship between the Boolean operators and the fundamental logic gates is illustrated below. In the illustration, the Boolean variables A and B correspond to the inputs to the circuit, and the variable Z corresponds to the output.\n\n\n\n\n\nAs in ordinary algebra, Boolean algebra uses parentheses to indicate which operands go with which operators. The Boolean expression A+(B⋅C) represents a completely different circuit from ( A+B)⋅C . In the first, B and C are fed into an and gate, with the result being sent (along with A) into an or gate. In the second, A and B are fed into an or gate, with the result being combined with C via an and gate.\nAs you may be beginning to suspect, there is a direct correspondence between Boolean expressions and logic circuits. Every logic circuit that can ever be constructed will have a corresponding Boolean expression, and every valid Boolean expression that can ever be written maps to an equivalent logic circuit. The process of converting between the two representations is quite mechanical: simply use the substitutions above, being sure to parenthesize Boolean expressions in a manner that preserves which operators go with which operands.\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to write the Boolean expression corresponding to the following circuit :\n\n\n\n\nBoolean algebra provides computer scientists and engineers a powerful tool for concisely representing circuits and reasoning about their behavior. While the details are beyond the scope of this lesson, Boolean algebra allows us to do things like prove that two different circuits compute the same function; or find simpler (and thus less expensive) ways of implementing the functionality of a circuit.\n\n\nOther gates\nAny device, whose operation can be defined in terms of a truth table or Boolean expression, can be implemented using only the fundamental logic gates: and, or, and not. However, a number of additional gates are usually defined, as they prove useful for practical purposes. For example, it is frequently the case that a not will immediately follow an and gate, like so:\n\n\n\n\n\nSince this is such a common occurrence, the circuit has been given a name (nand) and a gate symbol (the and symbol combined with the bubble from the not symbol). Similarly, not often follows or, so there is a nor gate whose symbol is the bubble from the not attached to the or symbol. The following figure illustrates both the nand and nor gates. Their behavior, in terms of Boolean expressions, is provided as well. It is important to remember that these gates are simply a convenience (a kind of shorthand), in that they allow a circuit to be constructed from fewer underlying components.\n\n\n\n\n\nAs another example, the basic and and or gates support only two inputs; however, a circuit designer will frequently need to and or or more than two inputs. For this reason multi-input and and or gates exist.\nThe following figure presents the three and four input and and or gates along with their Boolean expressions:\n\n\n\n\n\nWhile these gates are often quite convenient, remember that it is always possible to construct equivalent circuits from the underlying two-input gates. For example, the following circuit represents one possible implementation of a four-input and gate:\n\n\n\n\n\nIts Boolean expression is Z=( A⋅B)⋅(C⋅D) . Note, however, that it could be designed differently (with a different Boolean expression), yet still represent a four-input and gate. For example, Z=((A⋅B)⋅C)⋅D would also work. The other multi-input gates can be constructed in a similar manner.\nIn addition to multi-input and and or gates, multi-input nand and nor gates can be constructed. The symbols for these gates are identical to the symbols for the multi-input and and or gates, with the exception of a not bubble attached to the output of each gate symbol. Their Boolean expressions are also identical as well, except that a not bar appears above the right-hand side of the expression.\n\n\nCombinational circuits\n\n\n\n\n\n\nDefinition\n\n\n\nCombinational circuits are digital circuits that do not involve any kind of feedback. In other words, the output of a combinational circuit cannot be fed back into that circuit as input.\n\n\nIn this lesson, we will focus on the simplest combinational circuits. Let’s start with a relatively simple circuit, the exclusive or.\nAn exclusive or, or xor, has two inputs and a single output. Its behavior is defined by the following truth table, where the inputs are labeled A and B and the output is labeled Z:\n\n\n\n\n\nLike the standard two-input or, the xor produces a 1 (true) when either of its inputs are 1, and a 0 (false) when both of its inputs are 0. The difference between or and xor appears in the case when both inputs are 1. The standard or produces a 1 in this case. The xor generates a 0. In other words, the “exclusive or” outputs a 1 when either, but not both, of its inputs are 1.\nEnglish does not contain a unique word for expressing the idea of xor – the word “or” does double duty for both its “inclusive” and “exclusive” forms. However, one can usually tell from the context of a sentence which form is intended. For example, if you tell a child “you can have candy or popcorn,” the intended meaning is exclusive or – either candy or popcorn, but not both. On the other hand, if a friend says “I’d be happy winning either the Porsche or the Mercedes,” the intended meaning is inclusive or – you would certainly not expect your friend to become unhappy if he won both cars.\nNow that we understand the behavior of xor in terms of its inputs and outputs, we can turn our attention to the problem of designing a circuit with its behavior. But how are we to begin?\nOne approach that often gets you moving in the right direction is to examine the truth table to determine the various circumstances under which the circuit must produce a 1. In the case of xor, there are two such cases: one in which input A is 0 and input B is 1, and another in which input A is 1 and input B is 0. Once these cases have been identified, we proceed by designing sub-circuits that will produce 1 in each of the required cases. The final step is to combine the sub-circuits together using an or gate. This is necessary because the main circuit would be true under any of the cases in which the sub-circuits generate a 1.\nThe following sub-circuit will generate a 1 when input A is 0 and input B is 1. Its Boolean expression is \\[Z=\\overline{A}⋅B\\]\n\n\n\n\n\nIt works by negating A and feeding that result (together with B) into an and gate. Since both of the inputs to an and must be 1 for it to produce a 1, the original value of A must be 0, while the value of B must be 1. Under all other circumstances this sub-circuit produces 0. Thus, this circuit successfully captures the meaning of line two of the xor truth table.\nA sub-circuit to implement line three of the xor truth table can be constructed similarly. Its Boolean expression is \\[Z=A.\\overline{B}⋅\\]\n\n\n\n\n\nThis circuit generates a 1 whenever input A is 1 and B is 0. Under all other circumstances, it produces a 0. The following figure illustrates a complete xor circuit, which contains the two sub-circuits joined together by an or gate. This is reasonable since the xor can be true either by way of the first sub-circuit or the second. Note that due to the manner in which the two sub-circuits were constructed, it is impossible for both of them to be true at the same time.\n\n\n\n\n\nThe Boolean expression for this circuit is \\[Z=(A.\\overline{B})+(\\overline{A}⋅B)⋅\\]\nA new feature introduced in this circuit diagram is the connection point. Each of the two sub-circuits making up the xor requires access to both inputs. So the wires that represented these inputs had to be split in some way. We indicate a branch (or connection) point in a circuit diagram by a dot. Connection points allow a wire to be split so that its current state can flow to multiple destinations. Here is what a connection point looks like graphically:\n\n\n\n\n\nThe pin on the left is the input to the connection point, or connector. The top, right, and bottom pins are the outputs. Hence, this connector splits the input wire three ways. In the xor circuit diagram a twoway, rather than three-way split was required, so one of the output pins is not drawn.\nConnection points should not be confused with wires that just happen to cross one another by chance. In such a case there is no connection between the wires, so their signals do not interfere in any way. Think of the wires as insulated and just lying across one another. Wires that cross but are not connected are represented graphically in the following way:\n\n\n\n\n\nYou should convince yourself that the circuit above does indeed implement the truth table for xor. However, you should not come away from this discussion thinking that it is the only way (or even the most efficient way) to implement the xor behavior. The approach to circuit design of identifying the lines of the truth table that generate a 1, implementing sub-circuits to generate a 1 only under those circumstances, and then connecting all of the sub-circuits together via an or, works. But, it frequently results in circuits that are more complex than really necessary. For example, our implementation of xor requires five gates (not counting connectors). An implementation that requires only four gates can be developed from the Boolean expression \\(Z=( A+B)⋅(\\overline{A.B})\\) .\n\n\nComparators\n\n\n\n\n\n\nDefinition\n\n\n\nA comparator examines two input values to determine whether a particular condition is satisfied. If the inputs satisfy the condition, the comparator generates a 1 (true). If the inputs do not satisfy the condition, the comparator generates a 0 (false).\n\n\nThe most common type of comparator is the comparator for equality. This type of comparator determines whether two input values are identical. If the values are the same, the comparator generates a 1 (true). If the input values are different, the comparator generates a 0 (false).\nComparators come in different sizes, based on the width of their inputs. The simplest comparator is the one-bit comparator for equality. This circuit takes in two single-bit numbers and generates a 1 if they are equal and a 0 otherwise. Here is the truth table for the one-bit comparator for equality. The inputs are labeled A and B. The output is labeled Z:\n\n\n\n\n\nIn order to implement a circuit with this behavior, we first note the lines of the truth table that generate a 1. These are lines one and four. Let’s look first at line four. This line of the table says that Z should be 1 when both A and B are 1. Implementing a circuit that will generate 1 under this circumstance, and no other, is trivial since the two-input and gate already does exactly what we want.\nProducing a sub-circuit for line one of the table isn’t really that difficult either. In order to have a subcircuit that generates 1 when both inputs are 0, simply invert (or not) each of the inputs and send the results into an and gate. Putting these ideas together, we develop the following circuit:\n\n\n\n\n\nIts expression is \\(Z=(A+B)+(\\overline{A.B})\\)\nThe design for the one-bit comparator for equality can be extended to multi-bit numbers. For example, the two-bit comparator for equality has the following truth table:\n\n\n\n\n\nThis table consists of 16 rows since it has four input bits. Remember, the number of rows of a truth table is always \\(2^n\\), where n is the number of input bits. In the table, \\(A_0\\) represents the low-order bit of input A, and \\(A_1\\) represents the high-order bit of A. Likewise, \\(B_0\\) is the low-order bit of B and \\(B_1\\) is the high-order bit. Hence, the first row of the table represents inputs of A=00 and B=00, which are equal; so the output, Z, is 1 (true). Likewise, the second row of the table represents A=00 and B=01, which are not equal; so the output, Z, is 0 (false).\nTo get a clearer idea of what this circuit does, let’s examine only those rows of the table in which the output is 1 (true). There are four cases in which the two-bit comparator for equality generates a 1:\n\n\n\n\n\nThe first row corresponds to the case where both A and B are zero (00). The second row captures the case where both inputs are one (01), the third where the inputs are two (10), and the fourth where they are three (11). Note that these are binary inputs, and the fact that, for example, 11 is three deals with the representation of binary numbers and their decimal equivalents. This is something that will be covered in detail later.\nHow can we build a circuit with this behavior? In the previous examples we built sub-circuits to handle each case in which the main circuit was to produce 1. We then connected the sub-circuits together using an or gate. Because the present circuit is a multi-bit version of a circuit we have already constructed, we will take a different approach to the circuit design problem. When attempting to construct a multi-bit version of a single-bit circuit, it is best to approach the problem by looking for ways in which single-bit versions of the circuit can be interconnected to form the multi-bit circuit.\nA careful inspection of the above table will show that a 1 should be generated whenever the low-order bits of both inputs (\\(A_0\\) and \\(B_0\\)) are equal and the high-order bits of the inputs (\\(A_1\\) and \\(B_1\\)) are equal as well. Hence, routing inputs \\(A_0\\) and \\(B_0\\) into a one-bit comparator for equality and inputs \\(A_1\\) and \\(B_1\\) into a separate one-bit comparator for equality, then sending both of these results into an and gate, will produce a circuit with the desired behavior. Here is the circuit:\n\n\n\n\n\nThe circuit is based on the idea that two-bit numbers are equal if both their low-order and high-order bits are identical. An actual implementation of the circuit would require that the boxes marked “one-bit comparator” be replaced with comparator circuitry along the lines of that shown earlier. In addition to comparators for equality, comparators for other conditions (such as less than and greater than) can be constructed. While most of these are not covered in this lesson, here’s a brief example of the truth table for the one-bit comparator for less than (i.e., A &lt; B):\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nCan you come up with the circuit for this logic in the space below? Here’s an example circuit:\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nCan you complete the truth table for the greater than comparator (i.e., A &gt; B)?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nCan you come up with the circuit for this logic in the space below?"
  },
  {
    "objectID": "lesson06.html",
    "href": "lesson06.html",
    "title": "Searching and Sorting",
    "section": "",
    "text": "One of the most common tasks that is undertaken in Computer Science is the task of searching. We can search for many things: a value (like a phone number), a number (like seven), a position (like who finished the race in second place), or an object (like an image of a dog). Typically, searching will require doing a specific task over and over again (i.e., searching in one position, and then searching in another position), until we find what we are looking for. This requires repetition. We have already learned how to deal with and represent repetition. Our first task is to design an algorithm that can be used to search for a given value.\n\n\n\n\n\n\nActivity 1\n\n\n\n\n\nFor this activity, you will participate in the demonstration of an algorithm to find some value (specifically, the maximum value) in a list of values. Approximately ten students will be asked to stand in front of the class. These will be known as memory students; that is, they represent a subset of a computer’s memory. Each memory student will secretly write a number of their choosing on a post-it note. Collectively, this represents a list of numbers stored in the computer’s memory. One other student, known as the computer student, will represent the computer as it executes the algorithm. This student will follow instructions (like a computer would) and keep track of a single value representing the current maximum value in the list of numbers. This student will have a few post-it notes (or a small dry-erase board) to keep up with the current maximum value. The computer student understands several instructions: START – instructs the computer student to go to the beginning of the memory student line; MOVE – instructs the computer student to move to the next memory student in the line; COMPARE – instructs the computer student to compare the number of the current memory student to the one currently recorded and respond with greater, if the current memory student’s number is greater, or less, otherwise; STORE – instructs the computer student to record the current memory student’s number; and DISPLAY – instructs the computer student to display the currently recorded value.\nThe suggested algorithm is described in pseudocode as follows:\n    START\n    STORE\n    repeat\n        MOVE\n        COMPARE\n        if the response is greater\n        then\n            STORE\n        end\n    until the computer student is at the end of the memory student line\n    DISPLAY\nThe suggested algorithm is described using a flowchart as follows:\n\n\n\n\n\nNote that the algorithm initially instructs the computer student to record the first number in the list and assume it to be the maximum value. Technically, it is the maximum value at that time, but it provides a starting point. The algorithm then proceeds to compare each of the other values in the list and replaces the recorded maximum value when a greater value is encountered in the list.\nAt the end of the algorithm, the computer student should have the maximum value recorded on the post-it note, which is revealed to the class. For effect, the memory students should subsequently display theirpost-it notes to confirm the maximum value.\nNote that the algorithm works regardless of the arrangement of the memory students.\n\n\n\n\n\nThe activity above was a demonstration of the sequential search. Sequential searching has a lot of applications in computer science.\n\n\n\n\n\n\nDefinition\n\n\n\nSequential search (also known as linear search) is the process of locating a value in a list of values by checking each element, one at a time, until either the value is located or the end of the list has been reached.\n\n\nThe algorithm described in the activity above can be represented more generally in pseudocode as follows:\n    1: i ← 1\n    2: max ← value of item i in the list\n    3: repeat\n    4:      increment i\n    5:      if value of item i in the list &gt; max\n    6:      then\n    7:          max ← value of item i in the list\n    8:      end\n    9: until i = the length of the list\n    10: display max\nThis algorithm searches for (and displays) the largest value in a list of numbers. How could it be modified to search for (and display) the smallest value in a list of numbers?\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to modify the algorithm above:\n\n\n\nThe sequential search can also be used to find a specific value (such as 100) instead of something more general as we did above (such as the maximum value). How could the algorithm that finds the maximum value be modified to search for a specified value and display whether it was found (or not)?\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to modify the algorithm above:\n\n\n\nIs this algorithm efficient? What happens if the value searched for is not in the list? What happens if the value searched for is near the beginning of the list? We observe that, if the value searched for is near the beginning of the list, the algorithm sets the variable found to true but continues to look through the remainder of the list. This is not very efficient. Consider a list of 1 million values such that the value searched for happens to be found at the beginning of the list. The algorithm above would absolutely find the value at the beginning of the list; however, it would then continue to needlessly search through the remaining 999,999 values in the list. There is no stop condition in the case that the value searched for is found. We can fix this quite easily, however, by slightly modifying the algorithm:\n    1:n ← value to search for\n    2: i ← 1\n    3: found ← false\n    4: repeat\n    5:      if value of item i in the list = n\n    6:      then\n    7:          found ← true\n    8:      end\n    9:      increment i\n    10: until i &gt; the length of the list or found = true\n    11: display found\nBy adding an additional exit condition (something that terminates the repetition), we can capture the case that the value is found at any point in the list and immediately terminate the search. When designing algorithms, we must carefully examine them to find inconsistencies, problems, and to ensure that they, in fact, solve the problem. In addition, we must not forget to consider efficiency, performance,and scalability. For a very short list, efficiency may not matter; however, we don’t usually deal with small amounts of data in practice.\nHere is an example of the sequential search for the value 80 applied to a list containing the following values: 10, 20, 30, 40, 50, 60, 70, 80, 90, 100:\n\nThe search begins by comparing the target value, 80, with the first value in the list, 10. Since 10 ≠ 80, then the search continues to the next value in the list. This is continued until the value is found in the eighth position. This sequential search requires a total of eight searches to find the target value. We can apply the sequential search to a number guessing problem: on average, how many tries would it take to correctly guess a number from one to 1,000? In the best case, one. In the worst case, 1,000. On average, 500.\nLet’s generalize this for a list of n values and call the tries comparisons (since that’s what is actually being done). In the best case, it takes one comparison (if the target value is at the beginning of the list).\nIn the worst case, it takes n comparisons (if the target value is at the end of the list). If many searches for various target values were performed, an average number of comparisons could be calculated – and we would find that approximately half of the list would need to be searched through. This should not be surprising, since the good cases (where the target value is at the front of the list), and the bad cases (where the target value is at the end of the list) tend to cancel each other out over many searches. On average, searching for a target value in a list containing n items requires n / 2 comparisons.\nCan you come up with a better algorithm to correctly guess a randomly picked number from one to 1,000? Students will be paired up in groups of two. One student (called the picker) will secretly pick a number from one to 1,000; the other student (called the guesser) will attempt to guess the secret numberunder the following constraints:\n    The guesser submits a single number at a time;\n    The picker replies HIGHER if the secret number is higher than the guesser's submission, or\n    LOWER otherwise; and\n    The picker replies CORRECT if the guesser's submission is correct.\nEach group of students should design an algorithm to correctly guess the number picked by the picker. Record the number of guesses that it took to guess correctly. Then switch places: the picker becomes the guesser and vice versa.\n\n\n\nSome of you may have realized that the runtime of a sequential search is dependent on the size of the list that is being searched. Sequentially searching through a list of 1,000 items (as in the activity above) will typically take ten times as long as searching through a list of 100 items (i.e., 100 is one-tenth of 1,000). In the best case, the item will be found at the beginning of the list (i.e., it requires searching through only one item). In the worst case, the item will be found at the end of the list or not found at all (i.e., it requires searching through the entire list). On average, the algorithm would have to search through about half of the list.\nConsider the scenario of searching for a name that corresponds to a specific phone number in a phone book. This is the reverse of what is normally done (i.e., searching for a phone number that corresponds to a given name). How could this be done? The only way is to perform a sequential search, starting at the beginning of the phone book. This could take a long time, and it would be utterly depressing if the phone number was not found in the phone book. While the sequential search is effective, there are scenarios (like this one) where a more efficient way of searching is preferable.\nConsider the normal approach to searching a phone book for a phone number that corresponds to a given name. A sequential search would require starting the search at the beginning of the phone book and continue until either the name is found or until the entire phone book is exhausted. However, a phone book has a specific quality that can be taken advantage of which makes searching significantly easier and faster: it is ordered in a meaningful way. The names in a phone book are arranged in alphabetical order. This makes searching easier in that only a small subset of the names have to actually be searched through. When searching through a phone book, the usual process is to thumb through it until the first letter of the given name is reached. From there, a sequential search (of sorts) is performed to search for the given name.\nA method that may be better suited for computing is to open the phone book in the middle. If the given name starts with a letter in the alphabet that comes before the one that is there, then the right half of the phone book can be ignored. With a single comparison, half of the phone book has been eliminated. This strategy can be continued by shifting to the part of the phone book that represents the halfway point in the first half of the phone book. Another comparison is performed to determine if the given name appears before or after this point. This continues until the given name is found. With each check, half of the remaining portion is eliminated.\nThis strategy can be used to guess a number from one to 1,000 much more efficiently than by doing a sequential search. So how is the halfway point (or middle value) calculated? Given a list of n items, we calculate the middle as follows:\n\\[ \\left\\lfloor \\frac{n}{2} \\right\\rfloor +1  \\]\nNote that the brackets represent the floor function which means to round down to the largest previous integer. For example, the floor of 3.14 is 3, and the floor of 27.9 is 27. For an odd number of values, this selects the middle value (i.e., there are an equal number of values on either side of the selected value). For an even number of values, this selects the value to the right of the “middle” (i.e., there is one more value to the left of the selected value than there are to the right). The following simpler formula may, at first, seem equivalent: \\[\\left\\lceil \\frac{n}{2} \\right\\rceil\\]\nIndeed, it is for odd values of n; e.g., for n=5 \\[ \\left\\lfloor \\frac{5}{2}\\right\\rfloor+1=⌊2.5 ⌋+1=2+1=3 \\] \\[\\left\\lceil \\frac{5}{2}\\right\\rceil=⌈2.5⌉=3 \\]\nHowever, it is not equivalent for even values of n; e.g., for n=6: \\[ \\left\\lfloor \\frac{6}{2}\\right\\rfloor+1=⌊3⌋+1=3+1=4 \\] \\[\\left\\lceil \\frac{6}{2}\\right\\rceil=⌈3⌉=3 \\]\nSome of you may have naturally implemented this algorithm in the activity above. Let’s formally define it now in pseudocode:\n    1: repeat\n    2:      n ← number of items in the current portion of the list\n    3:      mid ← floor(n / 2) + 1\n    4:      guess mid\n    5:      if response is HIGHER\n    6:      then\n    7:          discard the left half of the list\n    8:      else if response is LOWER\n    9:      then\n    10:         discard the right half of the list\n    11:     end\n    12: until guess is correct\nThis algorithm is known as a binary search. Note that it supposes that every number from 1 to n is in thelist as in the activity above.\n\n\n\n\n\n\nDefinition\n\n\n\nBinary search is the process of locating a value in an ordered list of values by repeatedly comparing the value in the middle of the relevant portion of the list to the desired value and discarding the appropriate half of the list. Searching terminates when either the desired value is located or the list can no longer be divided in half.\n\n\nHere is an example of the binary search for the value 70 applied to a list containing the following values:\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100:\n\nThe list is initially split in the middle at 60 (since there are 10 values, and floor(10/2) + 1 is 6 – the sixth value in the list). Since 60 is less than 70, we can safely discard the left half of the list (including the split value 60) and continue with the right half of the list: 70, 80, 90, 100. This smaller sub-list is split in the middle at 90. Since 90 is greater than 70, we can safely discard the right half of the sub-list (including the split value 90) and continue with the left half of the sub-list: 70, 80. This smaller sub-list is split in the middle at 80. Since 80 is greater than 70, we can safely discard the right half of the sub-list (including the split value 80) and continue with the left half of the sub-list: 70. This sub-list has a single value (70) which, when compared to 70, is found to be the target value. In four comparisons, the target value was found in the list.\nWhat would happen if we tried to search the list for a value that the list doesn’t contain? Here is an example of the binary search for the value 45 applied to a list containing the same values as before:\n\nIt should be evident that the binary search is significantly faster than a sequential search. It turns out that guessing a number from 1 to 10,000 using the binary search will take, at most, 14 guesses. Intuitively, this is because 10,000 can be divided in half roughly 14 times: 10,000 is reduced to 5,000, then to 2,500, then to 1,250, then to 625, then to 313, then to 157, then to 79, then to 40, then to 20, then to 10, then to 5, then to 3, then to 2, and finally to 1 (14 total splits). We can actually calculate this precisely by solving the following equation: \\[2^n= 10000\\]\nExponentiation is the reverse of logarithms. That is, \\(2^n= 10000\\) expresses the same relationship as \\(log_210000 = n\\). We can visualize how the binary search works to find a value in a list of 10,000 values by illustrating each guess (the middle value):\n\nConsider a simpler problem of guessing a number from 1 to 1,000. How many guesses would that take? We know that \\(2^{10} = 1024\\) and that \\(2^9= 512\\); therefore, 1,000 can be divided by two between 9 and 10 times. However, it’s evident that it’s closer to 10 than it is to 9. In fact, it is actually 9.97 times. Recall that, on average, it would take 500 guesses if the sequential search were used instead. The binary search is therefore 50 times faster than the sequential search for a list of 1,000 values (500 guesses / 10 guesses = 50). What about the comparison for a list of 1 billion values? The sequential search would take, on average, 500 million comparisons. The binary search would take, at worst, 30 comparisons. That’s almost 17 million times faster!\n\n\n\n\n\n\nDid you know?\n\n\n\nTo solve for n in \\(2^n= 1000\\), we can use the formula that expresses the inverse of raising two to a power:\\(log_210000 = n\\) . Logarithms represent the power to which some number, called the base (in this case, 2), must be raised to produce a given number (in this case, 1,000). Most calculators do not have a \\(log_2\\) function; however, they typically do have a \\(log_{10}\\) function (note that most calculators denote this as log and omit the base). We can convert easily by using the following conversion (where b is the given base and d is the desired base):\n\\[log_b{x}=\\frac{log_d{x}}{log_d{b}}\\]\nIn the example above where the given base is 2, the target base is 10, and x is 1000, we can convert as follows: \\[log_2{1000}=\\frac{log_{10}{1000}}{log_{10}{2}}=9.97\\]\nFor giggles, how many tries would it take to guess a number from one to 1 billion? \\[log_2{1billion}=\\frac{log_{10}{1billion}}{log_{10}{2}}=29.9\\]\n\n\nSearching for a target value in a list containing n items requires, at maximum, the following number of comparisons: \\[ ⌈log_2(n+1)⌉\\]\nNote that the brackets represent the ceiling function which means to round up to the smallest following integer. For example, the ceiling of 3.14 is 4, and the ceiling of 27.1 is 28. You may be confused why we’re taking the logarithm of \\(n+1\\). Consider the simplest case of a list containing a single item (i.e., n = 1).\\(⌈log_2(1+1)⌉ = 1\\). Clearly, a list containing a single value requires at most a single comparison!\nThe following table shows the number of comparisons required to search through a list of values ranging from 0 to 10,000 items using both the sequential search (average number of comparisons) and binary search (maximum number of comparisons). It also includes a performance measure that compares how much better the binary search is when compared to the sequential search. It is amazing to see the huge difference in the performance of the two algorithms:\n\n\nFor a list of 1,000 items, the binary search is roughly 50 times faster than the sequential search, and for a list of 10,000 items, the binary search is roughly 357 times faster. This, however, does not take into consideration that the binary search takes extra calculations (i.e., calculating the middle of the current portion of the list, discarding half of the list, etc). However, suppose that each binary search comparison takes 1/10 of a second and each sequential search comparison takes 1/1000 of a second. We can still observe that the binary search ridiculously outperforms the sequential search as illustrated in Figure 1.\nAlso note that the time it takes to initially order the list of numbers is not considered. Since the binary search requires the list to be ordered, it is worthwhile to investigate various ordering methods and their performance."
  },
  {
    "objectID": "lesson06.html#sequential-search",
    "href": "lesson06.html#sequential-search",
    "title": "Searching and Sorting",
    "section": "",
    "text": "The activity above was a demonstration of the sequential search. Sequential searching has a lot of applications in computer science.\n\n\n\n\n\n\nDefinition\n\n\n\nSequential search (also known as linear search) is the process of locating a value in a list of values by checking each element, one at a time, until either the value is located or the end of the list has been reached.\n\n\nThe algorithm described in the activity above can be represented more generally in pseudocode as follows:\n    1: i ← 1\n    2: max ← value of item i in the list\n    3: repeat\n    4:      increment i\n    5:      if value of item i in the list &gt; max\n    6:      then\n    7:          max ← value of item i in the list\n    8:      end\n    9: until i = the length of the list\n    10: display max\nThis algorithm searches for (and displays) the largest value in a list of numbers. How could it be modified to search for (and display) the smallest value in a list of numbers?\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to modify the algorithm above:\n\n\n\nThe sequential search can also be used to find a specific value (such as 100) instead of something more general as we did above (such as the maximum value). How could the algorithm that finds the maximum value be modified to search for a specified value and display whether it was found (or not)?\n\n\n\n\n\n\nActivity\n\n\n\n\n\nTry to modify the algorithm above:\n\n\n\nIs this algorithm efficient? What happens if the value searched for is not in the list? What happens if the value searched for is near the beginning of the list? We observe that, if the value searched for is near the beginning of the list, the algorithm sets the variable found to true but continues to look through the remainder of the list. This is not very efficient. Consider a list of 1 million values such that the value searched for happens to be found at the beginning of the list. The algorithm above would absolutely find the value at the beginning of the list; however, it would then continue to needlessly search through the remaining 999,999 values in the list. There is no stop condition in the case that the value searched for is found. We can fix this quite easily, however, by slightly modifying the algorithm:\n    1:n ← value to search for\n    2: i ← 1\n    3: found ← false\n    4: repeat\n    5:      if value of item i in the list = n\n    6:      then\n    7:          found ← true\n    8:      end\n    9:      increment i\n    10: until i &gt; the length of the list or found = true\n    11: display found\nBy adding an additional exit condition (something that terminates the repetition), we can capture the case that the value is found at any point in the list and immediately terminate the search. When designing algorithms, we must carefully examine them to find inconsistencies, problems, and to ensure that they, in fact, solve the problem. In addition, we must not forget to consider efficiency, performance,and scalability. For a very short list, efficiency may not matter; however, we don’t usually deal with small amounts of data in practice.\nHere is an example of the sequential search for the value 80 applied to a list containing the following values: 10, 20, 30, 40, 50, 60, 70, 80, 90, 100:\n\nThe search begins by comparing the target value, 80, with the first value in the list, 10. Since 10 ≠ 80, then the search continues to the next value in the list. This is continued until the value is found in the eighth position. This sequential search requires a total of eight searches to find the target value. We can apply the sequential search to a number guessing problem: on average, how many tries would it take to correctly guess a number from one to 1,000? In the best case, one. In the worst case, 1,000. On average, 500.\nLet’s generalize this for a list of n values and call the tries comparisons (since that’s what is actually being done). In the best case, it takes one comparison (if the target value is at the beginning of the list).\nIn the worst case, it takes n comparisons (if the target value is at the end of the list). If many searches for various target values were performed, an average number of comparisons could be calculated – and we would find that approximately half of the list would need to be searched through. This should not be surprising, since the good cases (where the target value is at the front of the list), and the bad cases (where the target value is at the end of the list) tend to cancel each other out over many searches. On average, searching for a target value in a list containing n items requires n / 2 comparisons.\nCan you come up with a better algorithm to correctly guess a randomly picked number from one to 1,000? Students will be paired up in groups of two. One student (called the picker) will secretly pick a number from one to 1,000; the other student (called the guesser) will attempt to guess the secret numberunder the following constraints:\n    The guesser submits a single number at a time;\n    The picker replies HIGHER if the secret number is higher than the guesser's submission, or\n    LOWER otherwise; and\n    The picker replies CORRECT if the guesser's submission is correct.\nEach group of students should design an algorithm to correctly guess the number picked by the picker. Record the number of guesses that it took to guess correctly. Then switch places: the picker becomes the guesser and vice versa."
  },
  {
    "objectID": "lesson06.html#binary-search",
    "href": "lesson06.html#binary-search",
    "title": "Searching and Sorting",
    "section": "",
    "text": "Some of you may have realized that the runtime of a sequential search is dependent on the size of the list that is being searched. Sequentially searching through a list of 1,000 items (as in the activity above) will typically take ten times as long as searching through a list of 100 items (i.e., 100 is one-tenth of 1,000). In the best case, the item will be found at the beginning of the list (i.e., it requires searching through only one item). In the worst case, the item will be found at the end of the list or not found at all (i.e., it requires searching through the entire list). On average, the algorithm would have to search through about half of the list.\nConsider the scenario of searching for a name that corresponds to a specific phone number in a phone book. This is the reverse of what is normally done (i.e., searching for a phone number that corresponds to a given name). How could this be done? The only way is to perform a sequential search, starting at the beginning of the phone book. This could take a long time, and it would be utterly depressing if the phone number was not found in the phone book. While the sequential search is effective, there are scenarios (like this one) where a more efficient way of searching is preferable.\nConsider the normal approach to searching a phone book for a phone number that corresponds to a given name. A sequential search would require starting the search at the beginning of the phone book and continue until either the name is found or until the entire phone book is exhausted. However, a phone book has a specific quality that can be taken advantage of which makes searching significantly easier and faster: it is ordered in a meaningful way. The names in a phone book are arranged in alphabetical order. This makes searching easier in that only a small subset of the names have to actually be searched through. When searching through a phone book, the usual process is to thumb through it until the first letter of the given name is reached. From there, a sequential search (of sorts) is performed to search for the given name.\nA method that may be better suited for computing is to open the phone book in the middle. If the given name starts with a letter in the alphabet that comes before the one that is there, then the right half of the phone book can be ignored. With a single comparison, half of the phone book has been eliminated. This strategy can be continued by shifting to the part of the phone book that represents the halfway point in the first half of the phone book. Another comparison is performed to determine if the given name appears before or after this point. This continues until the given name is found. With each check, half of the remaining portion is eliminated.\nThis strategy can be used to guess a number from one to 1,000 much more efficiently than by doing a sequential search. So how is the halfway point (or middle value) calculated? Given a list of n items, we calculate the middle as follows:\n\\[ \\left\\lfloor \\frac{n}{2} \\right\\rfloor +1  \\]\nNote that the brackets represent the floor function which means to round down to the largest previous integer. For example, the floor of 3.14 is 3, and the floor of 27.9 is 27. For an odd number of values, this selects the middle value (i.e., there are an equal number of values on either side of the selected value). For an even number of values, this selects the value to the right of the “middle” (i.e., there is one more value to the left of the selected value than there are to the right). The following simpler formula may, at first, seem equivalent: \\[\\left\\lceil \\frac{n}{2} \\right\\rceil\\]\nIndeed, it is for odd values of n; e.g., for n=5 \\[ \\left\\lfloor \\frac{5}{2}\\right\\rfloor+1=⌊2.5 ⌋+1=2+1=3 \\] \\[\\left\\lceil \\frac{5}{2}\\right\\rceil=⌈2.5⌉=3 \\]\nHowever, it is not equivalent for even values of n; e.g., for n=6: \\[ \\left\\lfloor \\frac{6}{2}\\right\\rfloor+1=⌊3⌋+1=3+1=4 \\] \\[\\left\\lceil \\frac{6}{2}\\right\\rceil=⌈3⌉=3 \\]\nSome of you may have naturally implemented this algorithm in the activity above. Let’s formally define it now in pseudocode:\n    1: repeat\n    2:      n ← number of items in the current portion of the list\n    3:      mid ← floor(n / 2) + 1\n    4:      guess mid\n    5:      if response is HIGHER\n    6:      then\n    7:          discard the left half of the list\n    8:      else if response is LOWER\n    9:      then\n    10:         discard the right half of the list\n    11:     end\n    12: until guess is correct\nThis algorithm is known as a binary search. Note that it supposes that every number from 1 to n is in thelist as in the activity above.\n\n\n\n\n\n\nDefinition\n\n\n\nBinary search is the process of locating a value in an ordered list of values by repeatedly comparing the value in the middle of the relevant portion of the list to the desired value and discarding the appropriate half of the list. Searching terminates when either the desired value is located or the list can no longer be divided in half.\n\n\nHere is an example of the binary search for the value 70 applied to a list containing the following values:\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100:\n\nThe list is initially split in the middle at 60 (since there are 10 values, and floor(10/2) + 1 is 6 – the sixth value in the list). Since 60 is less than 70, we can safely discard the left half of the list (including the split value 60) and continue with the right half of the list: 70, 80, 90, 100. This smaller sub-list is split in the middle at 90. Since 90 is greater than 70, we can safely discard the right half of the sub-list (including the split value 90) and continue with the left half of the sub-list: 70, 80. This smaller sub-list is split in the middle at 80. Since 80 is greater than 70, we can safely discard the right half of the sub-list (including the split value 80) and continue with the left half of the sub-list: 70. This sub-list has a single value (70) which, when compared to 70, is found to be the target value. In four comparisons, the target value was found in the list.\nWhat would happen if we tried to search the list for a value that the list doesn’t contain? Here is an example of the binary search for the value 45 applied to a list containing the same values as before:\n\nIt should be evident that the binary search is significantly faster than a sequential search. It turns out that guessing a number from 1 to 10,000 using the binary search will take, at most, 14 guesses. Intuitively, this is because 10,000 can be divided in half roughly 14 times: 10,000 is reduced to 5,000, then to 2,500, then to 1,250, then to 625, then to 313, then to 157, then to 79, then to 40, then to 20, then to 10, then to 5, then to 3, then to 2, and finally to 1 (14 total splits). We can actually calculate this precisely by solving the following equation: \\[2^n= 10000\\]\nExponentiation is the reverse of logarithms. That is, \\(2^n= 10000\\) expresses the same relationship as \\(log_210000 = n\\). We can visualize how the binary search works to find a value in a list of 10,000 values by illustrating each guess (the middle value):\n\nConsider a simpler problem of guessing a number from 1 to 1,000. How many guesses would that take? We know that \\(2^{10} = 1024\\) and that \\(2^9= 512\\); therefore, 1,000 can be divided by two between 9 and 10 times. However, it’s evident that it’s closer to 10 than it is to 9. In fact, it is actually 9.97 times. Recall that, on average, it would take 500 guesses if the sequential search were used instead. The binary search is therefore 50 times faster than the sequential search for a list of 1,000 values (500 guesses / 10 guesses = 50). What about the comparison for a list of 1 billion values? The sequential search would take, on average, 500 million comparisons. The binary search would take, at worst, 30 comparisons. That’s almost 17 million times faster!\n\n\n\n\n\n\nDid you know?\n\n\n\nTo solve for n in \\(2^n= 1000\\), we can use the formula that expresses the inverse of raising two to a power:\\(log_210000 = n\\) . Logarithms represent the power to which some number, called the base (in this case, 2), must be raised to produce a given number (in this case, 1,000). Most calculators do not have a \\(log_2\\) function; however, they typically do have a \\(log_{10}\\) function (note that most calculators denote this as log and omit the base). We can convert easily by using the following conversion (where b is the given base and d is the desired base):\n\\[log_b{x}=\\frac{log_d{x}}{log_d{b}}\\]\nIn the example above where the given base is 2, the target base is 10, and x is 1000, we can convert as follows: \\[log_2{1000}=\\frac{log_{10}{1000}}{log_{10}{2}}=9.97\\]\nFor giggles, how many tries would it take to guess a number from one to 1 billion? \\[log_2{1billion}=\\frac{log_{10}{1billion}}{log_{10}{2}}=29.9\\]\n\n\nSearching for a target value in a list containing n items requires, at maximum, the following number of comparisons: \\[ ⌈log_2(n+1)⌉\\]\nNote that the brackets represent the ceiling function which means to round up to the smallest following integer. For example, the ceiling of 3.14 is 4, and the ceiling of 27.1 is 28. You may be confused why we’re taking the logarithm of \\(n+1\\). Consider the simplest case of a list containing a single item (i.e., n = 1).\\(⌈log_2(1+1)⌉ = 1\\). Clearly, a list containing a single value requires at most a single comparison!\nThe following table shows the number of comparisons required to search through a list of values ranging from 0 to 10,000 items using both the sequential search (average number of comparisons) and binary search (maximum number of comparisons). It also includes a performance measure that compares how much better the binary search is when compared to the sequential search. It is amazing to see the huge difference in the performance of the two algorithms:\n\n\nFor a list of 1,000 items, the binary search is roughly 50 times faster than the sequential search, and for a list of 10,000 items, the binary search is roughly 357 times faster. This, however, does not take into consideration that the binary search takes extra calculations (i.e., calculating the middle of the current portion of the list, discarding half of the list, etc). However, suppose that each binary search comparison takes 1/10 of a second and each sequential search comparison takes 1/1000 of a second. We can still observe that the binary search ridiculously outperforms the sequential search as illustrated in Figure 1.\nAlso note that the time it takes to initially order the list of numbers is not considered. Since the binary search requires the list to be ordered, it is worthwhile to investigate various ordering methods and their performance."
  },
  {
    "objectID": "lesson06.html#bubble-sort",
    "href": "lesson06.html#bubble-sort",
    "title": "Searching and Sorting",
    "section": "Bubble sort",
    "text": "Bubble sort\nThe bubble sort processes a list of items from left-to-right. The sorted list is built, in place, from right-to-left; that is, the largest value in the list is placed in its final position first, and so on, in the same list. It works by repeatedly comparing two neighboring elements (i.e., in positions i and i+1).If the two neighboring elements are out of order, they are swapped. The algorithm advances the position i and repeats. If, at the end of one iteration of the entire list (also called a pass) any swaps were made, the Figure 1: Runtime comparison of sequential and binary search process is repeated. If no swaps were made, it means the list is sorted, and the process terminates. The following is an example of the bubble sort on the list [7 9 3 5 1], with the underlined elements showing where the comparisons are made in each pass and red indicating the sorted portion of the list:\n\n\n\n\n\nThis sort is called the bubble sort because, during each pass, larger values bubble to the end of the list. Note that the bubble sort required four passes through the list of items. That is, it needed to go through some portion of the list starting at the beginning, compare values, and potentially swap values four times. In general for a list of n items, the bubble sort requires n-1 passes through the list. Did you notice that, as each pass was made, fewer and fewer elements in the list were compared. In the first pass, for example, four comparisons were made; in the second pass, three comparisons were made; in the third pass, two comparisons were made; and in the final pass, only one comparison was made. If we consider all passes in aggregate, on average about half of the values were compared; therefore, for a list of n items, an average of n /2 comparisons are made at each pass.\nWe can now calculate the number of comparisons made using the bubble sort as follows:\n\\[comparisons = number of passes * average number of comparisons per pass\\]\nAs stated, for a list of n items, n-1 passes are required, each of which on average makes n/2 comparisons. In total, the number of comparisons made using the bubble sort is then:\n\\[(n−1)∗\\frac{n}{2}=\\frac{1}{2}n(n−1) =\\frac{1}{2}( n^2−n)\\]\nFor the list above of five items, the number of comparisons is then:\n\\[\\frac{1}{2}(5^2−5) =\\frac{1}{2}(20) = 10\\]\nIn each pass of the bubble sort on the list in the example above, swaps were made. Let’s take a look at an example where the list of items is almost already sorted:\n\n\n\n\n\nSince no swaps were made in pass 2, then the sort is immediately terminated. Terminating the bubble sort during a pass if no swaps are made is a tweak on the original bubble sort called the optimized bubble sort.\nThe method illustrated on the sort the list [7 9 3 5 1] in the table above is great for showing each comparison and illustrating the bubble sort in detail; however, it is overkill when simply showing how a list is sorted. We can slightly deviate from the method used previously and instead summarize each pass in a single row of the table. The underlined items in the list at each pass represent the unsorted portion of the list:\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nShow how the bubble sort works on the list [9 1 2 5 3 7] by completing the table below:"
  },
  {
    "objectID": "lesson06.html#selection-sort",
    "href": "lesson06.html#selection-sort",
    "title": "Searching and Sorting",
    "section": "Selection sort",
    "text": "Selection sort\nThe selection sort is probably the most natural approach to sorting. Most people would likely come up with this algorithm when asked to design one that, for example, reorders a line of people based on their height. The selection sort processes a list of items from left-to-right. The sorted list is also built, in place, from left-to-right; that is, the smallest value in the list is placed in its final position first, and so on. Since the list is sorted in place, we keep track of both an unsorted portion and a sorted portion. And since the list is built from left-to-right, then the sorted portion is on the left. The selection sort works by repeatedly finding the smallest value in the unsorted portion of the list and swapping it with the first value in the unsorted portion. This action increases the sorted portion of the list and shrinks the unsorted portion of the list by one value. This is repeated until there are no values in the unsorted portion of the list.\nThe following is an example of the selection sort on the list [7 9 3 5 1] with the underlined elements showing where the comparisons are made in each pass and red indicating the sorted portion of the list:\n\n\n\n\n\n\n\n\n\n\nNote that the selection sort also required four passes through the list of items. For a list of n items, the selection sort requires n-1 passes through the list. Again, note that as each pass was made, fewer and fewer elements in the list were compared. If we consider all passes in aggregate, on average about half of the values were compared; therefore, for a list of n items, an average of n /2 comparisons are made at each pass.\nWe can now calculate the number of comparisons made by using the formula defined above:\n\\[comparisons = number of passes * average number of comparisons per pass\\]\nFor a list of n items, n-1 passes are required, each of which on average makes n/2 comparisons. In total,the runtime performance of the selection sort is then: \\[(n−1)∗\\frac{n}{2}=\\frac{1}{2}n(n−1) =\\frac{1}{2}( n^2−n)\\]\nFor the list above of five items, the number of comparisons is then: \\[\\frac{1}{2}(5^2−5) =\\frac{1}{2}(20) = 10\\]\nAgain, we can show how the selection sort works by summarizing each pass in a single row of the table. The underlined items in the list at each pass represent the unsorted portion of the list:\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nThis is sufficient to show how the selection sort works.Can you design an algorithm in pseudocode for the selection sort?\n\n\n\n\n\n\n\n\n\nDid you know?\n\n\n\nNote the for-next construct in the pseudocode for the selection sort above. It is used to repeat a fixed or known number of times. You have already seen the repeat-until construct that repeats until some condition is true. A for-next construct can be rewritten into a repeat-until construct as follows:\nThe for-next version:\n    for i ← 1..n\n    ...\n    next\n\nThe repeat-until version:\n    i ← 1\n    repeat\n        ...\n        i ← i + 1\n    until i = n\nIt is not always possible to rewrite a repeat-until construct into a for-next construct; for example (assuming that the length of the list is unknown):\n    repeat\n        remove item from list\n    until the list is empty\nIn this case, there is no way of knowing when the list will be empty if we don’t originally know the length of the list (as assumed).\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nShow how the selection sort works on the list [9 1 2 5 3 7] by completing the table below:"
  },
  {
    "objectID": "lesson06.html#insertion-sort",
    "href": "lesson06.html#insertion-sort",
    "title": "Searching and Sorting",
    "section": "Insertion sort",
    "text": "Insertion sort\nThe insertion sort is the procedure that most people use to arrange a hand of cards. To begin to understand the algorithm, think of the list as having both a sorted portion and an unsorted portion (as we did in the previous sorts). The first item of the list is considered to be a sorted list one item long, with the rest of the list (items 2 through n) forming an unsorted portion.\nThe insertion sort removes the first item from the unsorted portion of the list and marks it as the item to be inserted. It then works its way from the back to the front of the sorted portion of the list, at each step comparing the item to be inserted with the current item. As long as the current item is larger than the item to be inserted, the algorithm continues moving backward through the sorted portion of the list. Eventually it will either reach the beginning of the sorted portion of the list or encounter an item that is less than or equal to the item to be inserted. When that happens the algorithm inserts the item at the current insertion point.\nThe entire process of selecting the first item from the unsorted portion of the list and scanning backwards through the sorted portion of the list for the insertion point is then repeated. Eventually, the unsorted portion of the list will be empty since all of the items will have been inserted into the sorted portion of the list. When this occurs, the sort is complete.\nThe following is an example of the insertion sort on the list [7 9 3 5 1] with the underlined elements showing where the comparisons are made in each pass, the bold value indicating the current first item in the unsorted portion of the list, and red indicating the sorted portion of the list:\n\n\n\n\n\nAgain, we can show how the insertion sort works by summarizing each pass in a single row of the table. The underlined items in the list at each pass represent the unsorted portion of the list:\n\n\n\n\n\n\n\n\n\n\n\nActivity\n\n\n\n\n\nShow how the insertion sort works on the list [9 1 2 5 3 7] by completing the table below:\n\n\n\n\n\n\n\n\nNote that the insertion sort required four passes through the list of items. For a list of n items, the insertion sort requires n-1 passes through the list, which is the same as both the bubble sort and the selection sort. However, the number of comparisons made at each pass is not so simple to calculate because it depends on the original state of the list. Sometimes, the first item in the unsorted portion of the list will be greater than everything in the sorted portion of the list, and therefore only require one comparison (to the last value in the sorted portion of the list). At other times, it may actually be the smallest value in the entire list and thus be compared to every value in the sorted portion of the list.\nSince the number of comparisons made in the insertion sort is not so straightforward, we will need to determine formulas that represent the number of comparisons for the worst case, best case, and average case.\nIn the best case, only a single comparison will be made at each pass (i.e., the first item in the unsorted portion of the list is in its proper place in the list). This will happen, for example, if the list is already sorted. For a list of n items, the insertion sort requires n-1 passes, and for each pass, one comparison is made in the best case. The total number of comparisons in the best case is then: \\[(n−1)∗1 = n−1\\]\nFor the list above of five items, the number of comparisons in the best case is then four (5 – 1 = 4). Here is an example on the already sorted list [1 2 3 4 5]:\n\n\n\n\n\n\n\n\n\n\nIn the worst case, the first item belongs at the beginning of the sorted portion of the list and therefore is compared to every value in the sorted portion of the list. In the first pass, only one comparison is made; in the second pass, two comparisons are made; and so on. On average, then, n/2 comparisons are made per pass. For a list of n items, the insertion sort requires n-1 passes, and for each pass, an average of n/2 comparisons are made in the worst case. The total number of comparisons in the worst case is then:\n\\[(n−1)∗\\frac{n}{2}=\\frac{1}{2}n(n−1) =\\frac{1}{2}( n^2−n)\\]\nFor a list of five items, the number of comparisons in the worst case is then:\n\\[\\frac{1}{2}(5^2−5) =\\frac{1}{2}(20) = 10\\]\nIn the first example shown with the list [7 9 3 5 1], the worst case indeed occurred (and 10 comparisons were made). Note that the list is nearly reverse sorted!\nFor the average case, we simply need to calculate the average of the average number of comparisons made in the best and worst cases. In the best case, only one comparison is made per pass; in the worst case, n/2 comparisons are made. The average is then n/4 comparisons. For a list of n items, the insertion sort requires n-1 passes, and for each pass, an average of n/4 comparisons are made in the average case. The total number of comparisons in the average case is then:\n\\[(n−1)∗\\frac{n}{4}=\\frac{1}{4}n(n−1) =\\frac{1}{4}( n^2−n)\\]\nFor a list of five items, the number of comparisons in the average case is then:\n\\[\\frac{1}{4}(5^2−5) =\\frac{1}{4}(20) = 5\\]\nTo summarize, an insertion sort of n items always requires exactly n-1 passes through the sorted portion of the list. What varies is the number of comparisons that must be performed per pass. The best case requires only one comparison per pass and occurs when attempting to sort a list that is already sorted. The worst case requires an average of n/2 comparisons per pass and occurs when the list is already sorted in reverse order. In the average case, only one half of the items in the sorted portion of the list will be examined during each pass before the insertion point is found – giving n/4 comparisons per pass."
  },
  {
    "objectID": "lesson06.html#comparing-sorts",
    "href": "lesson06.html#comparing-sorts",
    "title": "Searching and Sorting",
    "section": "Comparing sorts",
    "text": "Comparing sorts\nWhen comparing the insertion sort to other sorts, generally the average case formula is used since this represents the expected performance of the algorithm. Occasionally, knowledge of the worst case behavior of the algorithm is also important. Understanding this behavior is useful when attempting to determine or limit the maximum amount of time a computing system will take to reach an answer, even in the worst case. Such behavior is important in real time applications such as airplane flight control systems. The bubble sort and the selection sort always require exactly \\(1/2(n^2-n)\\) comparisons to sort n items. In the worst case, the insertion sort also requires \\(1/2(n^2-n)\\) comparisons. In the average (expected) case, however, the insertion sort requires \\(1/4(n^2-n)\\) comparisons, and therefore requires about one half of the comparisons needed by the bubble and selection sorts. Figure 2 shows the runtime comparison of the three sorts, considering a machine capable of performing 1 million comparisons per second. The smaller number of comparisons needed by the insertion sort means that it is generally a faster algorithm than the bubble or selection sorts, assuming a comparison takes the same amount of time in both algorithms (a reasonable assumption). The insertion sort will be expected to process a 10,000 item list in about 25 seconds (precisely 24.9975 seconds). The bubble and selection sorts are both expected to take about 50 seconds on the same problem (precisely 49.995 seconds) – or about twice as long.\n\n\n\nFigure 2: Runtime comparison of bubble, selection, and insertion sorts"
  }
]