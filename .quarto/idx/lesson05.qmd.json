{"title":"Introduction to Computer Architecture","markdown":{"yaml":{"title":"Introduction to Computer Architecture","format":{"html":{"toc":true,"toc-depth":2,"code-block-bg":true,"code-block-border-left":true}}},"headingText":"The layers of a computer system","containsRefs":false,"markdown":"\n\nComputer architecture is a wide branch of computer science that seeks to find answers to questions such as, “What makes up a computer?” and, “How is it that we can use a computer?” The answers to these questions are continuously changing, but we will attempt to give a simple answer in this lesson.\n\nIn a previous lesson, we discussed how computer hardware works. Recall that all general-purpose computers, at a minimum, consist of the following hardware components: a central processing unit(CPU), main memory, secondary storage, various input/output (I/O) devices, and a **data** **bus**. The data bus is like a highway that the other components use to communicate with each other. **Main memory** is used to store data and programs that are currently being used. **I/O devices** allow the outside world to communicate with the computer. The **CPU** is the device that is responsible for actually executing the instructions that make up a program.\n\nLet's further discuss the brains of the computer, the CPU. The operation of the **CPU** is governed by the instruction cycle.\n\n::: {.callout-tip title=\"Definition\" }\nThe **instruction cycle** is a procedure that consists of three phases: instruction fetch, instruction decode, and instruction execution\n:::\n\nThe CPU’s task is to perform the instruction cycle over and over until explicitly instructed to halt. The **fetch** phase of the instruction cycle consists of retrieving an instruction from memory. The **decode** phase concerns determining what actions the instruction is requesting the CPU to perform. Instruction **execution** involves performing the operation requested by the instruction.\n\n\nTo fully understand computer architecture, it is important to understand the idea of **abstraction** as it is used in the field of computer science. Abstraction is an idea of dealing with complex and interconnected systems whereby a user is only interested in the operations of a certain level of complexity and suppresses more complex details. Abstraction is analogous to looking at Google map of a large country,such as the USA. We can see the individual states, large lakes, surrounding oceans, and neighboring countries. At this level of abstraction, one is unable to see the finer details within a state (such as the names of cities, towns, and major roads). However, zooming in provides an increased level of detail. The entire country is no longer visible; instead, perhaps only a single state (e.g., Louisiana) and its neighbors are visible. At this zoomed in level, we can now see some of the cities and major roads. However, we cannot see some of the details of the zoomed out level such as the states that are not immediate neighbors or the oceans. If we zoom in to an even lower level, we can see street names,major buildings, and so on. Again, we lose some of the details at the higher levels. Dividing a complex system (like a map) into levels that progressively abstract away detail allows users of the system to only deal with information that is relevant at a given time.\n\n![Figure 1: The multiple layers of a computer](images\\image1.svg){ fig-align=\"center\" width=500px }\n\n\nA computer is a very complex system consisting of multiple layers (see Figure 1). At the very top is the user. Users interact with computers in a variety of ways. That is, they can (and do) interact directly with applications (like a spreadsheet application, a game, or a Web browser). Users can also interact directly with the operating system (e.g., through its GUI or via the console) and with system utilities (think of applications that are provided by the operating system). The** application layer** is the next layer immediately below the user. It is the layer that a computer user typically interacts with. For example, a user can type and send an email without needing to know how the characters on the screen are made to appear on another computer perhaps one thousand miles away. A user might double-click an audio file on the desktop without needing to know how the computer understands what a double-click is or how to “play” the audio file.\n\nThe next layer is the **operating system** layer. This layer understands user inputs (like typing or double-clicks) and figures out ways of interpreting and executing those inputs. There are many examples of\noperating systems (e.g., Linux, Windows, MacOS, Unix, Solaris). Of these, Window is still the most common. What is the operating system on your Raspberry Pi? At its core, the operating system is what allows users to interact with the computer and actually make use of it.\n\n**System utilities** are like applications, but provided directly by the operating system. In one sense, they provide an interface to certain parts of the operating system that allow users to do frequently needed things. For example, the system utility of copying or moving files is often used. Users don't have to install an application that permits copying and moving files around. This is a system utility provided by the operating system. Since system utilities are essentially embedded in the operating system, this layer\nsits at the same level as the operating system layer.\n\nThe layer beneath the operating system layer is the **hardware abstraction** layer (or HAL). Sometimes, this layer is referred to as the device driver layer. There are many different types and designs of\ncomputers, and this layer makes sure that the computer hardware acts the same regardless of the computer's design. For example, it makes sure that the “on” button switches on the computer regardless of where it is located. It makes sure that hitting a specific button opens the CD drive. It provides the operating system with clear instructions on how it can interact with the physical hardware of the\ncomputer.\n\nThe bottom layer is the **hardware layer**. It represents the physical, tangible stuff that you can see or touch (e.g., keyboard, monitor, mouse, case, power supply, motherboard, etc).\n\n\n# Fundamentals of digital logic\nBecoming really good at computer science means having a good understanding of all of the layers, what they do, and how they are used. We will spend most of this lesson dealing with the hardware layer.\n\nA lot of devices have two states: a voltage is high or low, a switch is open or closed, a light is on or off. There are many ways of modeling these two-state systems; some are very concrete and some are more abstract. We’ll look at a number of these models, beginning with simple models that are based on mechanical switches and light bulbs.\n\nOne of the most basic electrical connection is a light bulb that is either connected to a power source (or not). A slightly more complicated version of this includes a switch that can be either open or closed.These switches are similar to the electrical switches in your home. We will assume that these switches are connected to a source of power that can supply current. The potential of a power source, such as a battery, is called voltage and is measured in units called volts (V). Voltage sources typically have a positive and negative end (called a terminal), and the difference in the potential between both terminals is what we use as the measurement of voltage. Voltage sources can produce either alternating current (AC) or direct current (DC). With DC, one terminal is always positive, and the other is always negative. Examples of DC sources are batteries such as the ones you would put in a small radio, watch, or flashlight. With AC, the two terminals keep on swapping positive and negative roles very quickly (60 times per second!). Examples of AC sources are wall outlets that you would typically find in your home.\n\nThe simplest circuit that can be built contains a power supply, a single switch, and a light bulb. If the switch is open, the light is off; if the switch is closed, the light is on. The following figure illustrates both of these cases:\n\n![](images\\img5 (1).png){ fig-align=\"center\" width=900px }\n\nThe state of these two circuits can be expressed in table form as follows:\n\n![](images\\img5 (2).png){ fig-align=\"center\" width=190px }\n\nWe can increase the complexity of this circuit somewhat by adding a second switch between the first switch and the light bulb. This results in four possible configurations: (1) both switches are open; (2) the first switch is open and the second is closed; (3) the first switch is closed and the second is open; and (4) both switches are closed. This is illustrated in the figure below. These circuits are called **series circuits** since the two switches occur on the same path from the power source back to itself. In series circuits, when either one or both of the switches are open power will not flow, and the light bulb will be off. Only when both switches are closed does power flow, and the light bulb illuminates. Said another way: if both switch A **and** switch B are closed, then the light will turn on.\n\n![](images\\img5 (3).png){ fig-align=\"center\" width=1000px }\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb(on or off) is summarized in the following table:\n\n![](images\\img5 (4).png){ fig-align=\"center\" width=350px }\n\nAnother type of circuit can be designed using two switches. This second type of circuit arranges the\nswitches in parallel rather than in series. In a two-switch **parallel circuit**, each of the switches is placed\non a separate path between the power source and the light bulb. The figure below illustrates the four possible configurations of a two-switch parallel circuit. As was the case with the series circuits, there\nare four possible configurations of the circuit (in fact, they are exactly the same as before). When both\nswitches are open power does not flow and the light bulb is off. However, whenever either or both of\nthe switches are closed, power flows and the light will turn on. Said another way, if switch A **or** switch\nB is closed, then the light will turn on.\n\n![](images\\img5 (5).png){ fig-align=\"center\" width=1000px }\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb (on or off) is summarized in the following table:\n\n![](images\\img5 (6).png){ fig-align=\"center\" width=350px }\n\nMore complex circuits with three or more switches are possible!\n\n\n::: {.callout-important title=\"Activity 1: LED the Way (preview) \" collapse=\"false\" icon=false}\nThe next Raspberry Pi activity will involve implementing various circuits that illustrate some of the ones covered above. Initially, the Raspberry Pi will only be used as a power source. We will be\nconnecting it to a circuit prototyping board called a **breadboard**, and the Raspberry Pi will provide power to the breadboard. A breadboard is used to simplify the process of prototyping connections\nbetween electronic components. It allows the making of secure connections between simple electronic devices by simply plugging them into appropriate rows or columns of the board. Here's an example of\na breadboard:\n\n![](images\\breadboard.png){ fig-align=\"center\" width=500px }\n\nThe holes in the breadboard allow electronic components (including wires) to be connected to each other. Note that there are internal connections within the breadboard. Each row along the top and\nbottom of the breadboard is connected. In addition, each column in the center portion is connected; however, there is a disconnect across the center gap:\n\n![](images\\breadboard2.png){ fig-align=\"center\" width=500px }\n\n**The first part of the activity**\n\nThe first part of the Raspberry Pi activity will simply be to connect a power supply to a light. Since the Raspberry Pi provides DC, the light we will use is called an LED. We'll explain this later; but for now, here's an example of the connected electronic components for this part of the activity:\n\n**Circuit representation**\n\n![](images\\breadboard6.png){ fig-align=\"center\" width=500px }\n\nThe image above is an example of the topological layout of a circuit. That is, it does a pretty good job of showing how the circuit looks physically when connected. Of course, there are many more ways to layout this exact circuit, and this is just one way. This method of diagramming a circuit is called a **layout diagram** because it shows the physical layout of the electronic (and other) components.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nA **circuit diagram** (also known as a **schematic**) is another way of representing a circuit that only shows the connections and substitutes actual electronic components with standard symbols.\n:::\n\n![](images\\circuit diagram.png){ fig-align=\"center\" width=500px }\n\nHere's an example of the above circuit as a circuit diagram:\n\nA circuit diagram is a useful way to represent a circuit. Note how it can topologically be laid out in a number of ways. Various electronic components have unique symbols. For example (in the circuit\ndiagram above), the LED has the following symbol:\n\n![](images\\led.png){ fig-align=\"center\" width=100px }\n\nThe resistor has the following symbol:\n\n![](images\\resistor.png){ fig-align=\"center\" width=120px }\n\nThe large rectangular object with lines coming out of it is the Raspberry Pi. Technically, this represents the GPIO pins on the Raspberry Pi. We'll discuss this more later. We will also show more electronic components and their symbols later.\n\n**The components**\n\nLet's go through the components, one-by-one. At the bottom is the Raspberry Pi. You will notice that there are two wires connecting some pins on the RPi to the breadboard. We typically use red wires to\nsignify positive voltage and black wires to signify negative voltage. In DC, the negative side is called ground. So red wires connect positive power to something, and black wires connect something to\nground.\n\nThe red “light” in the circuit is called an **LED** (Light Emitting Diode). An LED is more convenient than a traditional light bulb, because it does not require high voltage in order to turn it on. In fact, it consumes such a small voltage that typical higher voltage levels would render the LED unusable. Be careful when using LEDs, and never connect them directly to a voltage source.\n\nAn LED allows current to flow through it in only one direction (from positive to negative). LEDs have a short leg and a long leg. The short leg is called the **cathode** and is the negative side. The long leg is called the **anode** and is the positive side. The head of an LED is also flat on one side: the negative (or cathode) side. LEDs come in various colors (the one in the circuit above is red, for example). The longer leg of an LED should **always** be connected to the positive side of your voltage source. If it isconnected backwards (i.e., with the shorter leg connected to the positive side), the LED will not light and may even burn out. For this reason, an LED should always be connected to a DC voltage source.\n\n![](images\\electronics_led_diagram.png){ fig-align=\"center\" width=300px }\n\nSince most power sources are too strong for typical LEDs, we must reduce the current somewhat so that\nthe LED does not become damaged. **Resistors** are typically used to resist the flow of electricity. When\nusing them with LEDs, we typically connect a resistor in series with the LED. It doesn't matter if the\nresistor is on the positive or negative side of the LED. It works the same in either case. Resistors come\nin various resistances. Resistance is measured in a unit called the ohm (Ω). Here is an example of a\n220Ω resistor:\n\n![](images\\220ohm resistor.png){ fig-align=\"center\" width=150px }\n\nWe can calculate the resistance required to resist the flow of electricity through the LED using Ohm's Law. Ohm's Law establishes a relationship between voltage, current, and resistance. Let's first fully define each of these:\n\n- **Voltage** is the difference in electric potential energy between two points. It can be considered as electric pressure and/or the work required to move electric charge between two points. The unit used to represent voltage is the **volt** (V).\n\n- **Current** is the flow of electric charge (or electrons moving through a wire). The unit used to represent current is the **ampere** (A), or **amps**. We typically used the symbol I to represent current in a mathematical formula (such as Ohm's Law).\n\n- **Resistance** is the measure of difficulty to pass an electric current through a conductor. A conductor is some material that allows the flow of electric current. The unit used to represent resistance is the ohm (Ω). We typically used the symbol R to represent resistance in a mathematical formula (such as Ohm's Law).\n\nOhm's Law is defined as the following:\n\n|                                           **V=IR**\n\nStated formally, the voltage (electric potential difference) across two points on a circuit is equivalent to the product of the current between those two points and the total resistance of all electrical devices present between those two points.\n\nConsider the LED circuit above, where the red LED requires a forward voltage of 2V (i.e., the amount of voltage required across the LED to light it) and has a forward current of 20mA (i.e., the amount of current flow required through the LED to sufficiently power it on). These values are provided in the data sheet of the LED. A **data sheet** is a document that provides technical information about an electrical component.\n\nWe can calculate the resistance required in the circuit to ensure that the LED lights up properly and is not possibly damaged by having too much current move through it or too much voltage across it.\nSuppose that our power source (the Raspberry Pi) provides 3.3V. The voltage difference across the source voltage and ground is 3.3V (since ground is at 0V). According to the data sheet, the LED requires 2V across its legs and requires 20mA of current through it. Using Ohm's Law we can solve for R. The value for V is 1.3V (3.3V at the source – 2V through the LED), and the value for I is 0.02A\n(20mA required through the LED). And now we solve:\n$$ V = I * R $$\n$$(3.3V−2V ) = 0.02 A * R $$\n$$ 1.3V = 0.02 A * R $$\n$$65 = R$$\n\nSo the resistance should be 65Ω. The closest valued resistor available is 68Ω. We can therefore use a 68Ω resistor in series with the LED. This should be sufficient to turn it on brightly without damaging it.\n\nYou may have noticed that resistors also have a wattage rating. To explain this, we must first discuss electric power. Electric power is the rate at which electric energy is transferred by a circuit. The unit used to represent power is the **watt** (W). Each component in a circuit dissipates power (as heat – usually through friction – as electrons move through the component). Therefore, each component has a\npower rating that provides a measure of how much power it can dissipate without breaking down. We can calculate the power dissipated in a circuit using a variant of Ohm's Law:\n\n|                                           **P=VI**\n\nThe power in a circuit is defined as the product of the voltage across two points on a circuit and the current between those two points. In the LED example above, the total power dissipated in the circuit is calculated as follows:\n$$P = V * I$$\n$$P = 3.3V * 0.02 A$$\n$$P = 0.066W$$\n\nTo calculate the power dissipated by each component, we simply need to isolate the voltage drop across each. The current is constant in the entire circuit. So for the LED, we can calculate the power\ndissipated as follows:\n\n$$P = V * I$$\n$$P = 2V * 0.02 A$$\n$$P = 0.04W$$\n\nSo we would need an LED rated at 0.04W. And for the resistor:\n\n$$P = V * I$$\n$$P = (3.3V −2V ) * 0.02 A$$\n$$P = 1.3V * 0.02 A$$\n$$P = 0.026W$$\n\nSo we would need a resistor rated at 0.026W.\n\nIn the end, we usually opt for a power rating that is greater than the actual power dissipated by the component (so that it can last a long time). A good target is not to exceed 60% of the wattage rating of the component. For the resistor, this means a power rating of 0.043W (0.026W / 0.6). Most typical resistors are rated at 0.25W (some are 0.125W and others are much higher). For the LED, this means a power rating of 0.067W (0.04W / 0.6), or 67mW. Most typical LEDs are rated at approximately 120mW. For this circuit, a typical LED rated at 120mW and a resistor rated at 1/8W would work just fine.\n\n\n:::\n\n\n::: {.callout-tip title=\"Did you know?\" icon=false}\nResistors have different values, and the value of a resistor can be determined by looking at the colored\nbands that surround its body. Because resistors are typically small in size (any letters written on one\nwould be too small to be easily read), engineers invented a color code that can be used to calculate the\nresistance of a resistor. There are multiple online resources that can teach you how to read the value of\na resistor from its colors.\n:::\n\n\n::: {.callout-tip title=\"Did you know? \" icon=false}\nBreadboards actually derive their name from a breadboard (i.e., a wooden board on which bread is often\ncut). This is because early versions of breadboards were made from the wooden bread cutting\nworkstations.\n:::\n\n# Logic gates\nGates are electronic versions of the mechanical switches introduced earlier. Some gates have multiple\ninputs, but all gates have a single output. Just as the switches and light bulbs of the previous examples\nwere always in either of two states, the inputs and outputs of gates are confined to two voltage states.\nThe voltage of every input to the gate, as well as the output from the gate, must be either high (positive\nvoltage) or low (0V, or ground). We use the symbol “1” to represent the high voltage state and “0” to\nrepresent the low voltage state.\n\nThere are three basic kinds of logic gates: and gates, or gates, and not gates. An **and** gate has two inputs\nand one output. The output is “1” (high) only when both inputs are “1” (high). In all other cases the\noutput of and is “0” (low). Here is the symbol for an and gate (where the two inputs are on the left, and\nthe output is on the right):\n\n![](images\\img5.png){ fig-align=\"center\" width=150px }\n\nWe can represent the possible states of a gate in a truth table.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nA **truth table** defines the meaning of a gate, or circuit, by listing every possible configuration of inputs along with the corresponding output.\n::: \n\nTraditionally, inputs are listed on the left side of the table with the output on the right. Each row of the\ntruth table represents one configuration that the circuit can be in. Truth tables for circuits with n inputs\nwill always have exactly 2n\nrows, one for each possible configuration of the inputs. The following is the\ntruth table for the and gate, where the inputs have been labeled A and B, and the output has been labeled\nZ:\n\n![](images\\img5 (7).png){ fig-align=\"center\" width=150px }\n\nSince the and gate has two inputs, its truth table will contain $2^2= 4$ rows. The first row of the truth table\nrepresents the situation in which both inputs to the and gate are low. In this case the output will be low\nas well. The second and third rows cover the cases in which one of the inputs is high and the other is\nlow. In line two, the first input is low and the second is high; whereas in line three, the first input is high\nand the second is low. In either case, the output is low. The final row of the table represents the\nsituation in which both inputs are high. In this case, the output will be high as well.\nThe functionality of the and gate can be implemented by the series circuit introduced earlier:\n\n![](images\\img5 (8).png){ fig-align=\"center\" width=900px }\n\nIf the switches represent the inputs, A and B, then this circuit correctly produces the output, Z, of an and\ngate (which is the light bulb in the circuit). In fact, compare the truth table for the and gate above with\nthe truth table for the circuit:\n\n![](images\\img5 (9).png){ fig-align=\"center\" width=350px }\n\nIf Open is replaced with 0 and Closed with 1, the tables are the same. The reason that truth tables are\ncalled as such is that if 1 is taken to mean true and 0 is taken to mean false, then the output of the table\ndefines the circumstances under which the specified logical operation is true. For example, in common\nEnglish usage, A and B will be true only when both A and B are true. The statement: “My cat is old and\nfat” is only true when the cat in question is both “old” and “fat.” If my pet cat were either young, or\nskinny, or both, then the statement would be false.\nThe thing that is so exceedingly cool about logic gates, and the circuits that implement them, is that very\nsimple devices can capture small parts of what humans consider logical reasoning. As you can well\nimagine, this idea caused great excitement when first discovered.\n\nThe **or** gate is similar to an and gate, in that it has two inputs and one output. The output of the or gate\nis 1 whenever either (or both) of the inputs are 1. The only case in which the output is 0 is when both of\nthe inputs are 0. Here is the symbol and truth table for the or gate:\n\n![](images\\img5 (10).png){ fig-align=\"center\" width=150px }\n\nAgain, the two inputs of the or gate are labeled A and B, and its output is labeled Z. Notice that the or gate can be implemented by the parallel circuit introduced earlier:\n\n![](images\\img5 (11).png){ fig-align=\"center\" width=900px }\n\n![](images\\img5 (12).png){ fig-align=\"center\" width=450px }\n\nYou should convince yourself that the behavior of the or gate captures the semantics of the word “or” as it is commonly used. The statement: “My cat is either on the couch or under the bed” is true if either the phrase “My cat is on the couch” is true or the phrase “my cat is under the bed” is true. The original statement is false only when neither of these phrases is true.\n\nThe third basic logic gate is the not gate. The **not** gate has a single input and a single output. The output is the inverse of the input. Here is the symbol and truth table for the not gate:\n\n![](images\\img5 (13).png){ fig-align=\"center\" width=150px }\n\nNote that this truth table consists of only two rows rather than four (as was the case with the and and or\ngates). This is consistent with the claim that truth tables contain exactly $2^n$ rows for an n input circuit. Since the *not* gate takes in only a single input, there are only two possible configurations that the gate can be in.\n\nAs with the and and *or* gates, the behavior of the not gate captures the semantics of the word. If the\nsentence: “My cat is black” is true, then the sentence “My cat is not black” would be false (and vice\nversa).\n\n# Combining gates\n\n![](images\\img5 (14).png){ fig-align=\"center\" width=550px }\n\nHere's its truth table:\n\n![](images\\img5 (15).png){ fig-align=\"center\" width=350px }\n\nSo long as either *A **or** B* is closed  **and** C is closed, then the light bulb is lit. C must be closed in order for the bulb to be lit.\n\nIt is natural to ask at this point what an equivalent circuit consisting of logic gates would look like.\nSince switches A and B are in parallel, this portion of the circuit can be represented using an or gate.\nThe output of that part of the circuit is in series with C, so it can be modeled with an and gate. The logic\ngate circuit shown below is thus equivalent to the switch circuit given above.\n\n![](images\\img5 (16).png){ fig-align=\"center\" width=350px }\n\nIn fact, here is the truth table for this circuit:\n\n![](images\\img5 (17).png){ fig-align=\"center\" width=200px }\n\nFor readability and to make it a bit easier to derive, we can expand the truth table to provide\nintermediate gate outputs as follows (where Z is the output of A or B, and Z' is the output of Z and C):\n\n\n![](images\\img5 (18).png){ fig-align=\"center\" width=200px }\n\n\nCan you fill in the truth table for the circuit below? Let Z represent the output of A and B, and Z'\nrepresent the output of Z or C.\n\n![](images\\img5 (19).png){ fig-align=\"center\" width=250px }\n\n\n![](images\\img5 (20).png){ fig-align=\"center\" width=200px }\n\n\n# Boolean algebra\n\nThe arithmetic that is used to reason about two-state systems was first developed by George Boole in 1854.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nBoolean algebra is a mathematics based on three fundamental operators: and, or, and not;\nand the variables on which they operate.\n:::\n\nBoolean variables are binary, having only two valid states: 1 (representing true) and 0 (representing false).\n\nThe operator and is written as a dot “ ⋅ ”, or is written as a plus “+”, and not is written as a horizontal\nbar drawn over the expression being negated. The behavior of these three Boolean operators is identical\nto the behavior of the corresponding logic gates. Thus, the expression A⋅B , meaning A and B, will be 1\n(true) when the variables A and B are both 1 (true). The expression A+B , meaning A or B, will be 1\nwhen either or both variables are 1. The expression not A (written A ), will be 0 when A is 1 and 1 when\nA is 0. The relationship between the Boolean operators and the fundamental logic gates is illustrated\nbelow. In the illustration, the Boolean variables A and B correspond to the inputs to the circuit, and the\nvariable Z corresponds to the output.\n\n![](images\\img5 (21).png){ fig-align=\"center\" width=650px }\n\nAs in ordinary algebra, Boolean algebra uses parentheses to indicate which operands go with which\noperators. The Boolean expression A+(B⋅C) represents a completely different circuit from ( A+B)⋅C .\nIn the first, B and C are fed into an and gate, with the result being sent (along with A) into an or gate. In\nthe second, A and B are fed into an or gate, with the result being combined with C via an and gate.\n\nAs you may be beginning to suspect, there is a direct correspondence between Boolean expressions and\nlogic circuits. Every logic circuit that can ever be constructed will have a corresponding Boolean\nexpression, and every valid Boolean expression that can ever be written maps to an equivalent logic\ncircuit. The process of converting between the two representations is quite mechanical: simply use the substitutions above, being sure to parenthesize Boolean expressions in a manner that preserves which\noperators go with which operands.\n\nTry to write the Boolean expression corresponding to the following circuit in the space below:\n\n![](images\\img5 (22).png){ fig-align=\"center\" width=350px }\n\nBoolean algebra provides computer scientists and engineers a powerful tool for concisely representing\ncircuits and reasoning about their behavior. While the details are beyond the scope of this lesson,\nBoolean algebra allows us to do things like prove that two different circuits compute the same function;\nor find simpler (and thus less expensive) ways of implementing the functionality of a circuit.\n\n# Other gates\nAny device, whose operation can be defined in terms of a truth table or Boolean expression, can be\nimplemented using only the fundamental logic gates: *and, or*, and *not*. However, a number of additional\ngates are usually defined, as they prove useful for practical purposes. For example, it is frequently the\ncase that a not will immediately follow an and gate, like so:\n\n![](images\\img5 (23).png){ fig-align=\"center\" width=300px }\n\nSince this is such a common occurrence, the circuit has been given a name (nand) and a gate symbol\n(the and symbol combined with the bubble from the not symbol). Similarly, not often follows or, so\nthere is a nor gate whose symbol is the bubble from the not attached to the or symbol. The following\nfigure illustrates both the nand and nor gates. Their behavior, in terms of Boolean expressions, is\nprovided as well. It is important to remember that these gates are simply a convenience (a kind of\nshorthand), in that they allow a circuit to be constructed from fewer underlying components.\n\n![](images\\img5 (24).png){ fig-align=\"center\" width=350px }\n\nAs another example, the basic and and or gates support only two inputs; however, a circuit designer will\nfrequently need to and or or more than two inputs. For this reason multi-input and and or gates exist.\n\nThe following figure presents the three and four input and and or gates along with their Boolean\nexpressions:\n\n![](images\\img5 (25).png){ fig-align=\"center\" width=300px }\n\nWhile these gates are often quite convenient, remember that it is always possible to construct equivalent\ncircuits from the underlying two-input gates. For example, the following circuit represents one possible\nimplementation of a four-input and gate:\n\n![](images\\img5 (26).png){ fig-align=\"center\" width=300px }\n\nIts Boolean expression is Z=( A⋅B)⋅(C⋅D) . Note, however, that it could be designed differently (with a\ndifferent Boolean expression), yet still represent a four-input and gate. For example, Z=((A⋅B)⋅C)⋅D\nwould also work. The other multi-input gates can be constructed in a similar manner.\n\nIn addition to multi-input and and or gates, multi-input nand and nor gates can be constructed. The\nsymbols for these gates are identical to the symbols for the multi-input and and or gates, with the\nexception of a not bubble attached to the output of each gate symbol. Their Boolean expressions are\nalso identical as well, except that a not bar appears above the right-hand side of the expression.\n\n# Combinational circuits\n::: {.callout-tip title=\"Definition\" icon=false}\n**Combinational circuits** are digital circuits that do not involve any kind of feedback. In\nother words, the output of a combinational circuit cannot be fed back into that circuit as input.\n\n:::\n\nIn this lesson, we will focus on the simplest combinational circuits. Let's start with a relatively simple\ncircuit, the exclusive or.\n\nAn exclusive or, or xor, has two inputs and a single output. Its behavior is defined by the following truth\ntable, where the inputs are labeled A and B and the output is labeled Z:\n\n![](images\\img5 (27).png){ fig-align=\"center\" width=150px }\n\nLike the standard two-input or, the xor produces a 1 (true) when either of its inputs are 1, and a 0 (false)\nwhen both of its inputs are 0. The difference between or and xor appears in the case when both inputs\nare 1. The standard or produces a 1 in this case. The xor generates a 0. In other words, the “exclusive\nor” outputs a 1 when either, but not both, of its inputs are 1.\n\nEnglish does not contain a unique word for expressing the idea of xor – the word “or” does double duty\nfor both its “inclusive” and “exclusive” forms. However, one can usually tell from the context of a\nsentence which form is intended. For example, if you tell a child “you can have candy or popcorn,” the\nintended meaning is exclusive or – either candy or popcorn, but not both. On the other hand, if a friend\nsays “I’d be happy winning either the Porsche or the Mercedes,” the intended meaning is inclusive or –\nyou would certainly not expect your friend to become unhappy if he won both cars.\n\nNow that we understand the behavior of xor in terms of its inputs and outputs, we can turn our attention\nto the problem of designing a circuit with its behavior. But how are we to begin?\n\nOne approach that often gets you moving in the right direction is to examine the truth table to determine\nthe various circumstances under which the circuit must produce a 1. In the case of *xor*, there are two\nsuch cases: one in which input A is 0 and input B is 1, and another in which input A is 1 and input B is 0.\nOnce these cases have been identified, we proceed by designing *sub-circuits* that will produce 1 in each\nof the required cases. The final step is to combine the sub-circuits together using an *or* gate. This is\nnecessary because the main circuit would be true under any of the cases in which the sub-circuits\ngenerate a 1.\n\nThe following sub-circuit will generate a 1 when input A is 0 and input B is 1. Its Boolean expression is\n$$Z=\\overline{A}⋅B$$\n\n![](images\\img5 (28).png){ fig-align=\"center\" width=300px }\n\nIt works by negating A and feeding that result (together with B) into an and gate. Since both of the\ninputs to an and must be 1 for it to produce a 1, the original value of A must be 0, while the value of B\nmust be 1. Under all other circumstances this sub-circuit produces 0. Thus, this circuit successfully\ncaptures the meaning of line two of the xor truth table.\n\nA sub-circuit to implement line three of the xor truth table can be constructed similarly. Its Boolean\nexpression is \n$$Z=A.\\overline{B}⋅$$\n\n![](images\\img5 (29).png){ fig-align=\"center\" width=300px }\n\nThis circuit generates a 1 whenever input A is 1 and B is 0. Under all other circumstances, it produces a 0. The following figure illustrates a complete xor circuit, which contains the two sub-circuits joined\ntogether by an or gate. This is reasonable since the xor can be true either by way of the first sub-circuit\nor the second. Note that due to the manner in which the two sub-circuits were constructed, it is\nimpossible for both of them to be true at the same time.\n\n![](images\\img5 (30).png){ fig-align=\"center\" width=350px }\n\nThe Boolean expression for this circuit is\n$$Z=(A.\\overline{B})+(\\overline{A}⋅B)⋅$$\n\nA new feature introduced in this circuit diagram is the connection point. Each of the two sub-circuits\nmaking up the xor requires access to both inputs. So the wires that represented these inputs had to be\nsplit in some way. We indicate a branch (or connection) point in a circuit diagram by a dot. Connection\npoints allow a wire to be split so that its current state can flow to multiple destinations. Here is what a\nconnection point looks like graphically:\n\n![](images\\img5 (31).png){ fig-align=\"center\" width=100px }\n\nThe pin on the left is the input to the connection point, or connector. The top, right, and bottom pins are\nthe outputs. Hence, this connector splits the input wire three ways. In the xor circuit diagram a twoway, rather than three-way split was required, so one of the output pins is not drawn.\n\nConnection points should not be confused with wires that just happen to cross one another by chance. In\nsuch a case there is no connection between the wires, so their signals do not interfere in any way. Think\nof the wires as insulated and just lying across one another. Wires that cross but are not connected are\nrepresented graphically in the following way:\n\n![](images\\img5 (32).png){ fig-align=\"center\" width=100px }\n\nYou should convince yourself that the circuit above does indeed implement the truth table for xor.\nHowever, you should not come away from this discussion thinking that it is the only way (or even the\nmost efficient way) to implement the xor behavior. The approach to circuit design of identifying the\nlines of the truth table that generate a 1, implementing sub-circuits to generate a 1 only under those\ncircumstances, and then connecting all of the sub-circuits together via an or, works. But, it frequently\nresults in circuits that are more complex than really necessary. For example, our implementation of xor\nrequires five gates (not counting connectors). An implementation that requires only four gates can be\ndeveloped from the Boolean expression $Z=( A+B)⋅(\\overline{A.B})$ .\n\n# Comparators\n::: {.callout-tip title=\"Definition\" icon=false}\nA **comparator** examines two input values to determine whether a particular condition is\nsatisfied. If the inputs satisfy the condition, the comparator generates a 1 (true). If the inputs do not\nsatisfy the condition, the comparator generates a 0 (false).\n:::\n\nThe most common type of comparator is the comparator for equality. This type of comparator\ndetermines whether two input values are identical. If the values are the same, the comparator generates\na 1 (true). If the input values are different, the comparator generates a 0 (false).\n\nComparators come in different sizes, based on the width of their inputs. The simplest comparator is the\none-bit comparator for equality. This circuit takes in two single-bit numbers and generates a 1 if they\nare equal and a 0 otherwise. Here is the truth table for the one-bit comparator for equality. The inputs\nare labeled A and B. The output is labeled Z:\n\n![](images\\img5 (33).png){ fig-align=\"center\" width=150px }\n\nIn order to implement a circuit with this behavior, we first note the lines of the truth table that generate a 1. These are lines one and four. Let’s look first at line four. This line of the table says that Z should be\n1 when both A and B are 1. Implementing a circuit that will generate 1 under this circumstance, and no\nother, is trivial since the two-input and gate already does exactly what we want.\n\nProducing a sub-circuit for line one of the table isn’t really that difficult either. In order to have a subcircuit that generates 1 when both inputs are 0, simply invert (or not) each of the inputs and send the\nresults into an and gate. Putting these ideas together, we develop the following circuit:\n\n![](images\\img5 (34).png){ fig-align=\"center\" width=300px }\n\nIts expression is $Z=(A+B)+(\\overline{A.B})$\n\nThe design for the one-bit comparator for equality can be extended to multi-bit numbers. For example,\nthe two-bit comparator for equality has the following truth table:\n\n![](images\\img5 (35).png){ fig-align=\"center\" width=200px }\n\nThis table consists of 16 rows since it has four input bits. Remember, the number of rows of a truth\ntable is always $2^n$, where n is the number of input bits. In the table, $A_0$ represents the low-order bit of\ninput A, and $A_1$ represents the high-order bit of A. Likewise, $B_0$ is the low-order bit of B and $B_1$ is the\nhigh-order bit. Hence, the first row of the table represents inputs of A=00 and B=00, which are equal; so\nthe output, Z, is 1 (true). Likewise, the second row of the table represents A=00 and B=01, which are not\nequal; so the output, Z, is 0 (false).\n\nTo get a clearer idea of what this circuit does, let’s examine only those rows of the table in which the\noutput is 1 (true). There are four cases in which the two-bit comparator for equality generates a 1:\n\n![](images\\img5 (36).png){ fig-align=\"center\" width=200px }\n\nThe first row corresponds to the case where both A and B are zero (00). The second row captures the\ncase where both inputs are one (01), the third where the inputs are two (10), and the fourth where they\nare three (11). Note that these are binary inputs, and the fact that, for example, 11 is three deals with the\nrepresentation of binary numbers and their decimal equivalents. This is something that will be covered\nin detail later.\n\nHow can we build a circuit with this behavior? In the previous examples we built sub-circuits to handle\neach case in which the main circuit was to produce 1. We then connected the sub-circuits together using\nan or gate. Because the present circuit is a multi-bit version of a circuit we have already constructed, we\nwill take a different approach to the circuit design problem. When attempting to construct a multi-bit\nversion of a single-bit circuit, it is best to approach the problem by looking for ways in which single-bit\nversions of the circuit can be interconnected to form the multi-bit circuit.\n\nA careful inspection of the above table will show that a 1 should be generated whenever the low-order\nbits of both inputs ($A_0$ and $B_0$) are equal and the high-order bits of the inputs ($A_1$ and $B_1$) are equal as\nwell. Hence, routing inputs $A_0$ and $B_0$ into a one-bit comparator for equality and inputs $A_1$ and $B_1$ into a\nseparate one-bit comparator for equality, then sending both of these results into an and gate, will\nproduce a circuit with the desired behavior. Here is the circuit:\n\n![](images\\img5 (37).png){ fig-align=\"center\" width=350px }\n\nThe circuit is based on the idea that two-bit numbers are equal if both their low-order and high-order bits\nare identical. An actual implementation of the circuit would require that the boxes marked “one-bit\ncomparator” be replaced with comparator circuitry along the lines of that shown earlier.\nIn addition to comparators for equality, comparators for other conditions (such as *less than* and *greater than*) can be constructed. While most of these are not covered in this lesson, here's a brief example of\nthe truth table for the one-bit comparator for less than (i.e., A < B):\n\n![](images\\img5 (38).png){ fig-align=\"center\" width=150px }\n\nCan you come up with the circuit for this logic in the space below? Here's an example circuit:\n\n|\n\n.\n\n|\n\n.\n\n\n\nCan you complete the truth table for the greater than comparator (i.e., A > B)?\n\n![](images\\img5 (39).png){ fig-align=\"center\" width=150px }\n\n\n\nCan you come up with the circuit for this logic in the space below? Here's an example circuit:\n\n","srcMarkdownNoYaml":"\n\nComputer architecture is a wide branch of computer science that seeks to find answers to questions such as, “What makes up a computer?” and, “How is it that we can use a computer?” The answers to these questions are continuously changing, but we will attempt to give a simple answer in this lesson.\n\nIn a previous lesson, we discussed how computer hardware works. Recall that all general-purpose computers, at a minimum, consist of the following hardware components: a central processing unit(CPU), main memory, secondary storage, various input/output (I/O) devices, and a **data** **bus**. The data bus is like a highway that the other components use to communicate with each other. **Main memory** is used to store data and programs that are currently being used. **I/O devices** allow the outside world to communicate with the computer. The **CPU** is the device that is responsible for actually executing the instructions that make up a program.\n\nLet's further discuss the brains of the computer, the CPU. The operation of the **CPU** is governed by the instruction cycle.\n\n::: {.callout-tip title=\"Definition\" }\nThe **instruction cycle** is a procedure that consists of three phases: instruction fetch, instruction decode, and instruction execution\n:::\n\nThe CPU’s task is to perform the instruction cycle over and over until explicitly instructed to halt. The **fetch** phase of the instruction cycle consists of retrieving an instruction from memory. The **decode** phase concerns determining what actions the instruction is requesting the CPU to perform. Instruction **execution** involves performing the operation requested by the instruction.\n\n\n# The layers of a computer system\nTo fully understand computer architecture, it is important to understand the idea of **abstraction** as it is used in the field of computer science. Abstraction is an idea of dealing with complex and interconnected systems whereby a user is only interested in the operations of a certain level of complexity and suppresses more complex details. Abstraction is analogous to looking at Google map of a large country,such as the USA. We can see the individual states, large lakes, surrounding oceans, and neighboring countries. At this level of abstraction, one is unable to see the finer details within a state (such as the names of cities, towns, and major roads). However, zooming in provides an increased level of detail. The entire country is no longer visible; instead, perhaps only a single state (e.g., Louisiana) and its neighbors are visible. At this zoomed in level, we can now see some of the cities and major roads. However, we cannot see some of the details of the zoomed out level such as the states that are not immediate neighbors or the oceans. If we zoom in to an even lower level, we can see street names,major buildings, and so on. Again, we lose some of the details at the higher levels. Dividing a complex system (like a map) into levels that progressively abstract away detail allows users of the system to only deal with information that is relevant at a given time.\n\n![Figure 1: The multiple layers of a computer](images\\image1.svg){ fig-align=\"center\" width=500px }\n\n\nA computer is a very complex system consisting of multiple layers (see Figure 1). At the very top is the user. Users interact with computers in a variety of ways. That is, they can (and do) interact directly with applications (like a spreadsheet application, a game, or a Web browser). Users can also interact directly with the operating system (e.g., through its GUI or via the console) and with system utilities (think of applications that are provided by the operating system). The** application layer** is the next layer immediately below the user. It is the layer that a computer user typically interacts with. For example, a user can type and send an email without needing to know how the characters on the screen are made to appear on another computer perhaps one thousand miles away. A user might double-click an audio file on the desktop without needing to know how the computer understands what a double-click is or how to “play” the audio file.\n\nThe next layer is the **operating system** layer. This layer understands user inputs (like typing or double-clicks) and figures out ways of interpreting and executing those inputs. There are many examples of\noperating systems (e.g., Linux, Windows, MacOS, Unix, Solaris). Of these, Window is still the most common. What is the operating system on your Raspberry Pi? At its core, the operating system is what allows users to interact with the computer and actually make use of it.\n\n**System utilities** are like applications, but provided directly by the operating system. In one sense, they provide an interface to certain parts of the operating system that allow users to do frequently needed things. For example, the system utility of copying or moving files is often used. Users don't have to install an application that permits copying and moving files around. This is a system utility provided by the operating system. Since system utilities are essentially embedded in the operating system, this layer\nsits at the same level as the operating system layer.\n\nThe layer beneath the operating system layer is the **hardware abstraction** layer (or HAL). Sometimes, this layer is referred to as the device driver layer. There are many different types and designs of\ncomputers, and this layer makes sure that the computer hardware acts the same regardless of the computer's design. For example, it makes sure that the “on” button switches on the computer regardless of where it is located. It makes sure that hitting a specific button opens the CD drive. It provides the operating system with clear instructions on how it can interact with the physical hardware of the\ncomputer.\n\nThe bottom layer is the **hardware layer**. It represents the physical, tangible stuff that you can see or touch (e.g., keyboard, monitor, mouse, case, power supply, motherboard, etc).\n\n\n# Fundamentals of digital logic\nBecoming really good at computer science means having a good understanding of all of the layers, what they do, and how they are used. We will spend most of this lesson dealing with the hardware layer.\n\nA lot of devices have two states: a voltage is high or low, a switch is open or closed, a light is on or off. There are many ways of modeling these two-state systems; some are very concrete and some are more abstract. We’ll look at a number of these models, beginning with simple models that are based on mechanical switches and light bulbs.\n\nOne of the most basic electrical connection is a light bulb that is either connected to a power source (or not). A slightly more complicated version of this includes a switch that can be either open or closed.These switches are similar to the electrical switches in your home. We will assume that these switches are connected to a source of power that can supply current. The potential of a power source, such as a battery, is called voltage and is measured in units called volts (V). Voltage sources typically have a positive and negative end (called a terminal), and the difference in the potential between both terminals is what we use as the measurement of voltage. Voltage sources can produce either alternating current (AC) or direct current (DC). With DC, one terminal is always positive, and the other is always negative. Examples of DC sources are batteries such as the ones you would put in a small radio, watch, or flashlight. With AC, the two terminals keep on swapping positive and negative roles very quickly (60 times per second!). Examples of AC sources are wall outlets that you would typically find in your home.\n\nThe simplest circuit that can be built contains a power supply, a single switch, and a light bulb. If the switch is open, the light is off; if the switch is closed, the light is on. The following figure illustrates both of these cases:\n\n![](images\\img5 (1).png){ fig-align=\"center\" width=900px }\n\nThe state of these two circuits can be expressed in table form as follows:\n\n![](images\\img5 (2).png){ fig-align=\"center\" width=190px }\n\nWe can increase the complexity of this circuit somewhat by adding a second switch between the first switch and the light bulb. This results in four possible configurations: (1) both switches are open; (2) the first switch is open and the second is closed; (3) the first switch is closed and the second is open; and (4) both switches are closed. This is illustrated in the figure below. These circuits are called **series circuits** since the two switches occur on the same path from the power source back to itself. In series circuits, when either one or both of the switches are open power will not flow, and the light bulb will be off. Only when both switches are closed does power flow, and the light bulb illuminates. Said another way: if both switch A **and** switch B are closed, then the light will turn on.\n\n![](images\\img5 (3).png){ fig-align=\"center\" width=1000px }\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb(on or off) is summarized in the following table:\n\n![](images\\img5 (4).png){ fig-align=\"center\" width=350px }\n\nAnother type of circuit can be designed using two switches. This second type of circuit arranges the\nswitches in parallel rather than in series. In a two-switch **parallel circuit**, each of the switches is placed\non a separate path between the power source and the light bulb. The figure below illustrates the four possible configurations of a two-switch parallel circuit. As was the case with the series circuits, there\nare four possible configurations of the circuit (in fact, they are exactly the same as before). When both\nswitches are open power does not flow and the light bulb is off. However, whenever either or both of\nthe switches are closed, power flows and the light will turn on. Said another way, if switch A **or** switch\nB is closed, then the light will turn on.\n\n![](images\\img5 (5).png){ fig-align=\"center\" width=1000px }\n\nThe relationship between the states of the two switches (open or closed) and the state of the light bulb (on or off) is summarized in the following table:\n\n![](images\\img5 (6).png){ fig-align=\"center\" width=350px }\n\nMore complex circuits with three or more switches are possible!\n\n\n::: {.callout-important title=\"Activity 1: LED the Way (preview) \" collapse=\"false\" icon=false}\nThe next Raspberry Pi activity will involve implementing various circuits that illustrate some of the ones covered above. Initially, the Raspberry Pi will only be used as a power source. We will be\nconnecting it to a circuit prototyping board called a **breadboard**, and the Raspberry Pi will provide power to the breadboard. A breadboard is used to simplify the process of prototyping connections\nbetween electronic components. It allows the making of secure connections between simple electronic devices by simply plugging them into appropriate rows or columns of the board. Here's an example of\na breadboard:\n\n![](images\\breadboard.png){ fig-align=\"center\" width=500px }\n\nThe holes in the breadboard allow electronic components (including wires) to be connected to each other. Note that there are internal connections within the breadboard. Each row along the top and\nbottom of the breadboard is connected. In addition, each column in the center portion is connected; however, there is a disconnect across the center gap:\n\n![](images\\breadboard2.png){ fig-align=\"center\" width=500px }\n\n**The first part of the activity**\n\nThe first part of the Raspberry Pi activity will simply be to connect a power supply to a light. Since the Raspberry Pi provides DC, the light we will use is called an LED. We'll explain this later; but for now, here's an example of the connected electronic components for this part of the activity:\n\n**Circuit representation**\n\n![](images\\breadboard6.png){ fig-align=\"center\" width=500px }\n\nThe image above is an example of the topological layout of a circuit. That is, it does a pretty good job of showing how the circuit looks physically when connected. Of course, there are many more ways to layout this exact circuit, and this is just one way. This method of diagramming a circuit is called a **layout diagram** because it shows the physical layout of the electronic (and other) components.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nA **circuit diagram** (also known as a **schematic**) is another way of representing a circuit that only shows the connections and substitutes actual electronic components with standard symbols.\n:::\n\n![](images\\circuit diagram.png){ fig-align=\"center\" width=500px }\n\nHere's an example of the above circuit as a circuit diagram:\n\nA circuit diagram is a useful way to represent a circuit. Note how it can topologically be laid out in a number of ways. Various electronic components have unique symbols. For example (in the circuit\ndiagram above), the LED has the following symbol:\n\n![](images\\led.png){ fig-align=\"center\" width=100px }\n\nThe resistor has the following symbol:\n\n![](images\\resistor.png){ fig-align=\"center\" width=120px }\n\nThe large rectangular object with lines coming out of it is the Raspberry Pi. Technically, this represents the GPIO pins on the Raspberry Pi. We'll discuss this more later. We will also show more electronic components and their symbols later.\n\n**The components**\n\nLet's go through the components, one-by-one. At the bottom is the Raspberry Pi. You will notice that there are two wires connecting some pins on the RPi to the breadboard. We typically use red wires to\nsignify positive voltage and black wires to signify negative voltage. In DC, the negative side is called ground. So red wires connect positive power to something, and black wires connect something to\nground.\n\nThe red “light” in the circuit is called an **LED** (Light Emitting Diode). An LED is more convenient than a traditional light bulb, because it does not require high voltage in order to turn it on. In fact, it consumes such a small voltage that typical higher voltage levels would render the LED unusable. Be careful when using LEDs, and never connect them directly to a voltage source.\n\nAn LED allows current to flow through it in only one direction (from positive to negative). LEDs have a short leg and a long leg. The short leg is called the **cathode** and is the negative side. The long leg is called the **anode** and is the positive side. The head of an LED is also flat on one side: the negative (or cathode) side. LEDs come in various colors (the one in the circuit above is red, for example). The longer leg of an LED should **always** be connected to the positive side of your voltage source. If it isconnected backwards (i.e., with the shorter leg connected to the positive side), the LED will not light and may even burn out. For this reason, an LED should always be connected to a DC voltage source.\n\n![](images\\electronics_led_diagram.png){ fig-align=\"center\" width=300px }\n\nSince most power sources are too strong for typical LEDs, we must reduce the current somewhat so that\nthe LED does not become damaged. **Resistors** are typically used to resist the flow of electricity. When\nusing them with LEDs, we typically connect a resistor in series with the LED. It doesn't matter if the\nresistor is on the positive or negative side of the LED. It works the same in either case. Resistors come\nin various resistances. Resistance is measured in a unit called the ohm (Ω). Here is an example of a\n220Ω resistor:\n\n![](images\\220ohm resistor.png){ fig-align=\"center\" width=150px }\n\nWe can calculate the resistance required to resist the flow of electricity through the LED using Ohm's Law. Ohm's Law establishes a relationship between voltage, current, and resistance. Let's first fully define each of these:\n\n- **Voltage** is the difference in electric potential energy between two points. It can be considered as electric pressure and/or the work required to move electric charge between two points. The unit used to represent voltage is the **volt** (V).\n\n- **Current** is the flow of electric charge (or electrons moving through a wire). The unit used to represent current is the **ampere** (A), or **amps**. We typically used the symbol I to represent current in a mathematical formula (such as Ohm's Law).\n\n- **Resistance** is the measure of difficulty to pass an electric current through a conductor. A conductor is some material that allows the flow of electric current. The unit used to represent resistance is the ohm (Ω). We typically used the symbol R to represent resistance in a mathematical formula (such as Ohm's Law).\n\nOhm's Law is defined as the following:\n\n|                                           **V=IR**\n\nStated formally, the voltage (electric potential difference) across two points on a circuit is equivalent to the product of the current between those two points and the total resistance of all electrical devices present between those two points.\n\nConsider the LED circuit above, where the red LED requires a forward voltage of 2V (i.e., the amount of voltage required across the LED to light it) and has a forward current of 20mA (i.e., the amount of current flow required through the LED to sufficiently power it on). These values are provided in the data sheet of the LED. A **data sheet** is a document that provides technical information about an electrical component.\n\nWe can calculate the resistance required in the circuit to ensure that the LED lights up properly and is not possibly damaged by having too much current move through it or too much voltage across it.\nSuppose that our power source (the Raspberry Pi) provides 3.3V. The voltage difference across the source voltage and ground is 3.3V (since ground is at 0V). According to the data sheet, the LED requires 2V across its legs and requires 20mA of current through it. Using Ohm's Law we can solve for R. The value for V is 1.3V (3.3V at the source – 2V through the LED), and the value for I is 0.02A\n(20mA required through the LED). And now we solve:\n$$ V = I * R $$\n$$(3.3V−2V ) = 0.02 A * R $$\n$$ 1.3V = 0.02 A * R $$\n$$65 = R$$\n\nSo the resistance should be 65Ω. The closest valued resistor available is 68Ω. We can therefore use a 68Ω resistor in series with the LED. This should be sufficient to turn it on brightly without damaging it.\n\nYou may have noticed that resistors also have a wattage rating. To explain this, we must first discuss electric power. Electric power is the rate at which electric energy is transferred by a circuit. The unit used to represent power is the **watt** (W). Each component in a circuit dissipates power (as heat – usually through friction – as electrons move through the component). Therefore, each component has a\npower rating that provides a measure of how much power it can dissipate without breaking down. We can calculate the power dissipated in a circuit using a variant of Ohm's Law:\n\n|                                           **P=VI**\n\nThe power in a circuit is defined as the product of the voltage across two points on a circuit and the current between those two points. In the LED example above, the total power dissipated in the circuit is calculated as follows:\n$$P = V * I$$\n$$P = 3.3V * 0.02 A$$\n$$P = 0.066W$$\n\nTo calculate the power dissipated by each component, we simply need to isolate the voltage drop across each. The current is constant in the entire circuit. So for the LED, we can calculate the power\ndissipated as follows:\n\n$$P = V * I$$\n$$P = 2V * 0.02 A$$\n$$P = 0.04W$$\n\nSo we would need an LED rated at 0.04W. And for the resistor:\n\n$$P = V * I$$\n$$P = (3.3V −2V ) * 0.02 A$$\n$$P = 1.3V * 0.02 A$$\n$$P = 0.026W$$\n\nSo we would need a resistor rated at 0.026W.\n\nIn the end, we usually opt for a power rating that is greater than the actual power dissipated by the component (so that it can last a long time). A good target is not to exceed 60% of the wattage rating of the component. For the resistor, this means a power rating of 0.043W (0.026W / 0.6). Most typical resistors are rated at 0.25W (some are 0.125W and others are much higher). For the LED, this means a power rating of 0.067W (0.04W / 0.6), or 67mW. Most typical LEDs are rated at approximately 120mW. For this circuit, a typical LED rated at 120mW and a resistor rated at 1/8W would work just fine.\n\n\n:::\n\n\n::: {.callout-tip title=\"Did you know?\" icon=false}\nResistors have different values, and the value of a resistor can be determined by looking at the colored\nbands that surround its body. Because resistors are typically small in size (any letters written on one\nwould be too small to be easily read), engineers invented a color code that can be used to calculate the\nresistance of a resistor. There are multiple online resources that can teach you how to read the value of\na resistor from its colors.\n:::\n\n\n::: {.callout-tip title=\"Did you know? \" icon=false}\nBreadboards actually derive their name from a breadboard (i.e., a wooden board on which bread is often\ncut). This is because early versions of breadboards were made from the wooden bread cutting\nworkstations.\n:::\n\n# Logic gates\nGates are electronic versions of the mechanical switches introduced earlier. Some gates have multiple\ninputs, but all gates have a single output. Just as the switches and light bulbs of the previous examples\nwere always in either of two states, the inputs and outputs of gates are confined to two voltage states.\nThe voltage of every input to the gate, as well as the output from the gate, must be either high (positive\nvoltage) or low (0V, or ground). We use the symbol “1” to represent the high voltage state and “0” to\nrepresent the low voltage state.\n\nThere are three basic kinds of logic gates: and gates, or gates, and not gates. An **and** gate has two inputs\nand one output. The output is “1” (high) only when both inputs are “1” (high). In all other cases the\noutput of and is “0” (low). Here is the symbol for an and gate (where the two inputs are on the left, and\nthe output is on the right):\n\n![](images\\img5.png){ fig-align=\"center\" width=150px }\n\nWe can represent the possible states of a gate in a truth table.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nA **truth table** defines the meaning of a gate, or circuit, by listing every possible configuration of inputs along with the corresponding output.\n::: \n\nTraditionally, inputs are listed on the left side of the table with the output on the right. Each row of the\ntruth table represents one configuration that the circuit can be in. Truth tables for circuits with n inputs\nwill always have exactly 2n\nrows, one for each possible configuration of the inputs. The following is the\ntruth table for the and gate, where the inputs have been labeled A and B, and the output has been labeled\nZ:\n\n![](images\\img5 (7).png){ fig-align=\"center\" width=150px }\n\nSince the and gate has two inputs, its truth table will contain $2^2= 4$ rows. The first row of the truth table\nrepresents the situation in which both inputs to the and gate are low. In this case the output will be low\nas well. The second and third rows cover the cases in which one of the inputs is high and the other is\nlow. In line two, the first input is low and the second is high; whereas in line three, the first input is high\nand the second is low. In either case, the output is low. The final row of the table represents the\nsituation in which both inputs are high. In this case, the output will be high as well.\nThe functionality of the and gate can be implemented by the series circuit introduced earlier:\n\n![](images\\img5 (8).png){ fig-align=\"center\" width=900px }\n\nIf the switches represent the inputs, A and B, then this circuit correctly produces the output, Z, of an and\ngate (which is the light bulb in the circuit). In fact, compare the truth table for the and gate above with\nthe truth table for the circuit:\n\n![](images\\img5 (9).png){ fig-align=\"center\" width=350px }\n\nIf Open is replaced with 0 and Closed with 1, the tables are the same. The reason that truth tables are\ncalled as such is that if 1 is taken to mean true and 0 is taken to mean false, then the output of the table\ndefines the circumstances under which the specified logical operation is true. For example, in common\nEnglish usage, A and B will be true only when both A and B are true. The statement: “My cat is old and\nfat” is only true when the cat in question is both “old” and “fat.” If my pet cat were either young, or\nskinny, or both, then the statement would be false.\nThe thing that is so exceedingly cool about logic gates, and the circuits that implement them, is that very\nsimple devices can capture small parts of what humans consider logical reasoning. As you can well\nimagine, this idea caused great excitement when first discovered.\n\nThe **or** gate is similar to an and gate, in that it has two inputs and one output. The output of the or gate\nis 1 whenever either (or both) of the inputs are 1. The only case in which the output is 0 is when both of\nthe inputs are 0. Here is the symbol and truth table for the or gate:\n\n![](images\\img5 (10).png){ fig-align=\"center\" width=150px }\n\nAgain, the two inputs of the or gate are labeled A and B, and its output is labeled Z. Notice that the or gate can be implemented by the parallel circuit introduced earlier:\n\n![](images\\img5 (11).png){ fig-align=\"center\" width=900px }\n\n![](images\\img5 (12).png){ fig-align=\"center\" width=450px }\n\nYou should convince yourself that the behavior of the or gate captures the semantics of the word “or” as it is commonly used. The statement: “My cat is either on the couch or under the bed” is true if either the phrase “My cat is on the couch” is true or the phrase “my cat is under the bed” is true. The original statement is false only when neither of these phrases is true.\n\nThe third basic logic gate is the not gate. The **not** gate has a single input and a single output. The output is the inverse of the input. Here is the symbol and truth table for the not gate:\n\n![](images\\img5 (13).png){ fig-align=\"center\" width=150px }\n\nNote that this truth table consists of only two rows rather than four (as was the case with the and and or\ngates). This is consistent with the claim that truth tables contain exactly $2^n$ rows for an n input circuit. Since the *not* gate takes in only a single input, there are only two possible configurations that the gate can be in.\n\nAs with the and and *or* gates, the behavior of the not gate captures the semantics of the word. If the\nsentence: “My cat is black” is true, then the sentence “My cat is not black” would be false (and vice\nversa).\n\n# Combining gates\n\n![](images\\img5 (14).png){ fig-align=\"center\" width=550px }\n\nHere's its truth table:\n\n![](images\\img5 (15).png){ fig-align=\"center\" width=350px }\n\nSo long as either *A **or** B* is closed  **and** C is closed, then the light bulb is lit. C must be closed in order for the bulb to be lit.\n\nIt is natural to ask at this point what an equivalent circuit consisting of logic gates would look like.\nSince switches A and B are in parallel, this portion of the circuit can be represented using an or gate.\nThe output of that part of the circuit is in series with C, so it can be modeled with an and gate. The logic\ngate circuit shown below is thus equivalent to the switch circuit given above.\n\n![](images\\img5 (16).png){ fig-align=\"center\" width=350px }\n\nIn fact, here is the truth table for this circuit:\n\n![](images\\img5 (17).png){ fig-align=\"center\" width=200px }\n\nFor readability and to make it a bit easier to derive, we can expand the truth table to provide\nintermediate gate outputs as follows (where Z is the output of A or B, and Z' is the output of Z and C):\n\n\n![](images\\img5 (18).png){ fig-align=\"center\" width=200px }\n\n\nCan you fill in the truth table for the circuit below? Let Z represent the output of A and B, and Z'\nrepresent the output of Z or C.\n\n![](images\\img5 (19).png){ fig-align=\"center\" width=250px }\n\n\n![](images\\img5 (20).png){ fig-align=\"center\" width=200px }\n\n\n# Boolean algebra\n\nThe arithmetic that is used to reason about two-state systems was first developed by George Boole in 1854.\n\n::: {.callout-tip title=\"Definition\" icon=false}\nBoolean algebra is a mathematics based on three fundamental operators: and, or, and not;\nand the variables on which they operate.\n:::\n\nBoolean variables are binary, having only two valid states: 1 (representing true) and 0 (representing false).\n\nThe operator and is written as a dot “ ⋅ ”, or is written as a plus “+”, and not is written as a horizontal\nbar drawn over the expression being negated. The behavior of these three Boolean operators is identical\nto the behavior of the corresponding logic gates. Thus, the expression A⋅B , meaning A and B, will be 1\n(true) when the variables A and B are both 1 (true). The expression A+B , meaning A or B, will be 1\nwhen either or both variables are 1. The expression not A (written A ), will be 0 when A is 1 and 1 when\nA is 0. The relationship between the Boolean operators and the fundamental logic gates is illustrated\nbelow. In the illustration, the Boolean variables A and B correspond to the inputs to the circuit, and the\nvariable Z corresponds to the output.\n\n![](images\\img5 (21).png){ fig-align=\"center\" width=650px }\n\nAs in ordinary algebra, Boolean algebra uses parentheses to indicate which operands go with which\noperators. The Boolean expression A+(B⋅C) represents a completely different circuit from ( A+B)⋅C .\nIn the first, B and C are fed into an and gate, with the result being sent (along with A) into an or gate. In\nthe second, A and B are fed into an or gate, with the result being combined with C via an and gate.\n\nAs you may be beginning to suspect, there is a direct correspondence between Boolean expressions and\nlogic circuits. Every logic circuit that can ever be constructed will have a corresponding Boolean\nexpression, and every valid Boolean expression that can ever be written maps to an equivalent logic\ncircuit. The process of converting between the two representations is quite mechanical: simply use the substitutions above, being sure to parenthesize Boolean expressions in a manner that preserves which\noperators go with which operands.\n\nTry to write the Boolean expression corresponding to the following circuit in the space below:\n\n![](images\\img5 (22).png){ fig-align=\"center\" width=350px }\n\nBoolean algebra provides computer scientists and engineers a powerful tool for concisely representing\ncircuits and reasoning about their behavior. While the details are beyond the scope of this lesson,\nBoolean algebra allows us to do things like prove that two different circuits compute the same function;\nor find simpler (and thus less expensive) ways of implementing the functionality of a circuit.\n\n# Other gates\nAny device, whose operation can be defined in terms of a truth table or Boolean expression, can be\nimplemented using only the fundamental logic gates: *and, or*, and *not*. However, a number of additional\ngates are usually defined, as they prove useful for practical purposes. For example, it is frequently the\ncase that a not will immediately follow an and gate, like so:\n\n![](images\\img5 (23).png){ fig-align=\"center\" width=300px }\n\nSince this is such a common occurrence, the circuit has been given a name (nand) and a gate symbol\n(the and symbol combined with the bubble from the not symbol). Similarly, not often follows or, so\nthere is a nor gate whose symbol is the bubble from the not attached to the or symbol. The following\nfigure illustrates both the nand and nor gates. Their behavior, in terms of Boolean expressions, is\nprovided as well. It is important to remember that these gates are simply a convenience (a kind of\nshorthand), in that they allow a circuit to be constructed from fewer underlying components.\n\n![](images\\img5 (24).png){ fig-align=\"center\" width=350px }\n\nAs another example, the basic and and or gates support only two inputs; however, a circuit designer will\nfrequently need to and or or more than two inputs. For this reason multi-input and and or gates exist.\n\nThe following figure presents the three and four input and and or gates along with their Boolean\nexpressions:\n\n![](images\\img5 (25).png){ fig-align=\"center\" width=300px }\n\nWhile these gates are often quite convenient, remember that it is always possible to construct equivalent\ncircuits from the underlying two-input gates. For example, the following circuit represents one possible\nimplementation of a four-input and gate:\n\n![](images\\img5 (26).png){ fig-align=\"center\" width=300px }\n\nIts Boolean expression is Z=( A⋅B)⋅(C⋅D) . Note, however, that it could be designed differently (with a\ndifferent Boolean expression), yet still represent a four-input and gate. For example, Z=((A⋅B)⋅C)⋅D\nwould also work. The other multi-input gates can be constructed in a similar manner.\n\nIn addition to multi-input and and or gates, multi-input nand and nor gates can be constructed. The\nsymbols for these gates are identical to the symbols for the multi-input and and or gates, with the\nexception of a not bubble attached to the output of each gate symbol. Their Boolean expressions are\nalso identical as well, except that a not bar appears above the right-hand side of the expression.\n\n# Combinational circuits\n::: {.callout-tip title=\"Definition\" icon=false}\n**Combinational circuits** are digital circuits that do not involve any kind of feedback. In\nother words, the output of a combinational circuit cannot be fed back into that circuit as input.\n\n:::\n\nIn this lesson, we will focus on the simplest combinational circuits. Let's start with a relatively simple\ncircuit, the exclusive or.\n\nAn exclusive or, or xor, has two inputs and a single output. Its behavior is defined by the following truth\ntable, where the inputs are labeled A and B and the output is labeled Z:\n\n![](images\\img5 (27).png){ fig-align=\"center\" width=150px }\n\nLike the standard two-input or, the xor produces a 1 (true) when either of its inputs are 1, and a 0 (false)\nwhen both of its inputs are 0. The difference between or and xor appears in the case when both inputs\nare 1. The standard or produces a 1 in this case. The xor generates a 0. In other words, the “exclusive\nor” outputs a 1 when either, but not both, of its inputs are 1.\n\nEnglish does not contain a unique word for expressing the idea of xor – the word “or” does double duty\nfor both its “inclusive” and “exclusive” forms. However, one can usually tell from the context of a\nsentence which form is intended. For example, if you tell a child “you can have candy or popcorn,” the\nintended meaning is exclusive or – either candy or popcorn, but not both. On the other hand, if a friend\nsays “I’d be happy winning either the Porsche or the Mercedes,” the intended meaning is inclusive or –\nyou would certainly not expect your friend to become unhappy if he won both cars.\n\nNow that we understand the behavior of xor in terms of its inputs and outputs, we can turn our attention\nto the problem of designing a circuit with its behavior. But how are we to begin?\n\nOne approach that often gets you moving in the right direction is to examine the truth table to determine\nthe various circumstances under which the circuit must produce a 1. In the case of *xor*, there are two\nsuch cases: one in which input A is 0 and input B is 1, and another in which input A is 1 and input B is 0.\nOnce these cases have been identified, we proceed by designing *sub-circuits* that will produce 1 in each\nof the required cases. The final step is to combine the sub-circuits together using an *or* gate. This is\nnecessary because the main circuit would be true under any of the cases in which the sub-circuits\ngenerate a 1.\n\nThe following sub-circuit will generate a 1 when input A is 0 and input B is 1. Its Boolean expression is\n$$Z=\\overline{A}⋅B$$\n\n![](images\\img5 (28).png){ fig-align=\"center\" width=300px }\n\nIt works by negating A and feeding that result (together with B) into an and gate. Since both of the\ninputs to an and must be 1 for it to produce a 1, the original value of A must be 0, while the value of B\nmust be 1. Under all other circumstances this sub-circuit produces 0. Thus, this circuit successfully\ncaptures the meaning of line two of the xor truth table.\n\nA sub-circuit to implement line three of the xor truth table can be constructed similarly. Its Boolean\nexpression is \n$$Z=A.\\overline{B}⋅$$\n\n![](images\\img5 (29).png){ fig-align=\"center\" width=300px }\n\nThis circuit generates a 1 whenever input A is 1 and B is 0. Under all other circumstances, it produces a 0. The following figure illustrates a complete xor circuit, which contains the two sub-circuits joined\ntogether by an or gate. This is reasonable since the xor can be true either by way of the first sub-circuit\nor the second. Note that due to the manner in which the two sub-circuits were constructed, it is\nimpossible for both of them to be true at the same time.\n\n![](images\\img5 (30).png){ fig-align=\"center\" width=350px }\n\nThe Boolean expression for this circuit is\n$$Z=(A.\\overline{B})+(\\overline{A}⋅B)⋅$$\n\nA new feature introduced in this circuit diagram is the connection point. Each of the two sub-circuits\nmaking up the xor requires access to both inputs. So the wires that represented these inputs had to be\nsplit in some way. We indicate a branch (or connection) point in a circuit diagram by a dot. Connection\npoints allow a wire to be split so that its current state can flow to multiple destinations. Here is what a\nconnection point looks like graphically:\n\n![](images\\img5 (31).png){ fig-align=\"center\" width=100px }\n\nThe pin on the left is the input to the connection point, or connector. The top, right, and bottom pins are\nthe outputs. Hence, this connector splits the input wire three ways. In the xor circuit diagram a twoway, rather than three-way split was required, so one of the output pins is not drawn.\n\nConnection points should not be confused with wires that just happen to cross one another by chance. In\nsuch a case there is no connection between the wires, so their signals do not interfere in any way. Think\nof the wires as insulated and just lying across one another. Wires that cross but are not connected are\nrepresented graphically in the following way:\n\n![](images\\img5 (32).png){ fig-align=\"center\" width=100px }\n\nYou should convince yourself that the circuit above does indeed implement the truth table for xor.\nHowever, you should not come away from this discussion thinking that it is the only way (or even the\nmost efficient way) to implement the xor behavior. The approach to circuit design of identifying the\nlines of the truth table that generate a 1, implementing sub-circuits to generate a 1 only under those\ncircumstances, and then connecting all of the sub-circuits together via an or, works. But, it frequently\nresults in circuits that are more complex than really necessary. For example, our implementation of xor\nrequires five gates (not counting connectors). An implementation that requires only four gates can be\ndeveloped from the Boolean expression $Z=( A+B)⋅(\\overline{A.B})$ .\n\n# Comparators\n::: {.callout-tip title=\"Definition\" icon=false}\nA **comparator** examines two input values to determine whether a particular condition is\nsatisfied. If the inputs satisfy the condition, the comparator generates a 1 (true). If the inputs do not\nsatisfy the condition, the comparator generates a 0 (false).\n:::\n\nThe most common type of comparator is the comparator for equality. This type of comparator\ndetermines whether two input values are identical. If the values are the same, the comparator generates\na 1 (true). If the input values are different, the comparator generates a 0 (false).\n\nComparators come in different sizes, based on the width of their inputs. The simplest comparator is the\none-bit comparator for equality. This circuit takes in two single-bit numbers and generates a 1 if they\nare equal and a 0 otherwise. Here is the truth table for the one-bit comparator for equality. The inputs\nare labeled A and B. The output is labeled Z:\n\n![](images\\img5 (33).png){ fig-align=\"center\" width=150px }\n\nIn order to implement a circuit with this behavior, we first note the lines of the truth table that generate a 1. These are lines one and four. Let’s look first at line four. This line of the table says that Z should be\n1 when both A and B are 1. Implementing a circuit that will generate 1 under this circumstance, and no\nother, is trivial since the two-input and gate already does exactly what we want.\n\nProducing a sub-circuit for line one of the table isn’t really that difficult either. In order to have a subcircuit that generates 1 when both inputs are 0, simply invert (or not) each of the inputs and send the\nresults into an and gate. Putting these ideas together, we develop the following circuit:\n\n![](images\\img5 (34).png){ fig-align=\"center\" width=300px }\n\nIts expression is $Z=(A+B)+(\\overline{A.B})$\n\nThe design for the one-bit comparator for equality can be extended to multi-bit numbers. For example,\nthe two-bit comparator for equality has the following truth table:\n\n![](images\\img5 (35).png){ fig-align=\"center\" width=200px }\n\nThis table consists of 16 rows since it has four input bits. Remember, the number of rows of a truth\ntable is always $2^n$, where n is the number of input bits. In the table, $A_0$ represents the low-order bit of\ninput A, and $A_1$ represents the high-order bit of A. Likewise, $B_0$ is the low-order bit of B and $B_1$ is the\nhigh-order bit. Hence, the first row of the table represents inputs of A=00 and B=00, which are equal; so\nthe output, Z, is 1 (true). Likewise, the second row of the table represents A=00 and B=01, which are not\nequal; so the output, Z, is 0 (false).\n\nTo get a clearer idea of what this circuit does, let’s examine only those rows of the table in which the\noutput is 1 (true). There are four cases in which the two-bit comparator for equality generates a 1:\n\n![](images\\img5 (36).png){ fig-align=\"center\" width=200px }\n\nThe first row corresponds to the case where both A and B are zero (00). The second row captures the\ncase where both inputs are one (01), the third where the inputs are two (10), and the fourth where they\nare three (11). Note that these are binary inputs, and the fact that, for example, 11 is three deals with the\nrepresentation of binary numbers and their decimal equivalents. This is something that will be covered\nin detail later.\n\nHow can we build a circuit with this behavior? In the previous examples we built sub-circuits to handle\neach case in which the main circuit was to produce 1. We then connected the sub-circuits together using\nan or gate. Because the present circuit is a multi-bit version of a circuit we have already constructed, we\nwill take a different approach to the circuit design problem. When attempting to construct a multi-bit\nversion of a single-bit circuit, it is best to approach the problem by looking for ways in which single-bit\nversions of the circuit can be interconnected to form the multi-bit circuit.\n\nA careful inspection of the above table will show that a 1 should be generated whenever the low-order\nbits of both inputs ($A_0$ and $B_0$) are equal and the high-order bits of the inputs ($A_1$ and $B_1$) are equal as\nwell. Hence, routing inputs $A_0$ and $B_0$ into a one-bit comparator for equality and inputs $A_1$ and $B_1$ into a\nseparate one-bit comparator for equality, then sending both of these results into an and gate, will\nproduce a circuit with the desired behavior. Here is the circuit:\n\n![](images\\img5 (37).png){ fig-align=\"center\" width=350px }\n\nThe circuit is based on the idea that two-bit numbers are equal if both their low-order and high-order bits\nare identical. An actual implementation of the circuit would require that the boxes marked “one-bit\ncomparator” be replaced with comparator circuitry along the lines of that shown earlier.\nIn addition to comparators for equality, comparators for other conditions (such as *less than* and *greater than*) can be constructed. While most of these are not covered in this lesson, here's a brief example of\nthe truth table for the one-bit comparator for less than (i.e., A < B):\n\n![](images\\img5 (38).png){ fig-align=\"center\" width=150px }\n\nCan you come up with the circuit for this logic in the space below? Here's an example circuit:\n\n|\n\n.\n\n|\n\n.\n\n\n\nCan you complete the truth table for the greater than comparator (i.e., A > B)?\n\n![](images\\img5 (39).png){ fig-align=\"center\" width=150px }\n\n\n\nCan you come up with the circuit for this logic in the space below? Here's an example circuit:\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"output-file":"lesson05.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","title":"Introduction to Computer Architecture","code-block-bg":true,"code-block-border-left":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}